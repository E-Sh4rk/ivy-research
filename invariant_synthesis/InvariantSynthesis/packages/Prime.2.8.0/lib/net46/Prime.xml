<?xml version="1.0" encoding="utf-8"?>
<doc>
<assembly><name>Prime</name></assembly>
<members>
<member name="T:Prime.FSharpOption`1">
<summary>
 Alternative type of option when its name is reified.
</summary>
</member>
<member name="T:Prime.FOption`1">
<summary>
 An option type that doesn&apos;t generate garbage.
 TODO: P1: turn this into a struct DU when that is working in F# - and make sure matching does not allocate!
 TODO: document.
</summary>
</member>
<member name="T:Prime.EitherBuilder">
<summary>
 Builds an either monad.
</summary>
</member>
<member name="T:Prime.Either`2">
<summary>
 Haskell-style Either type.
</summary>
</member>
<member name="T:Prime.FSharpList`1">
<summary>
 Alternative type of list when its name is reified.
</summary>
</member>
<member name="T:Prime.FSharpSet`1">
<summary>
 Alternative type of set when its name is reified.
</summary>
</member>
<member name="T:Prime.FSharpMap`2">
<summary>
 Alternative type of map when it is reified to code.
</summary>
</member>
<member name="T:Prime.Rand">
<summary>
 An immutable random number generator using the xorshift* algorithm.
</summary>
</member>
<member name="T:Prime.PrettyPrinter">
<summary>
 Pretty prints Symbols, as well as strings by converting them to Symbols.
</summary>
</member>
<member name="T:Prime.Address`1">
<summary>
 Specifies the address of an identifiable value.
</summary>
</member>
<member name="T:Prime.AddressConverter">
<summary>
 Converts Address types.
</summary>
</member>
<member name="T:Prime.Relation`1">
<summary>
 A relation that can be resolved to an address via projection.
</summary>
</member>
<member name="T:Prime.RelationConverter">
<summary>
 Converts Relation types.
</summary>
</member>
<member name="T:Prime.KeyedCache`2">
<summary>
 Presents a purely-functional interface to a cached value.
 Works by associating a cached value with a given cache key such that the cached value remains valid when queried
 for using the same cache key (as decided by a simple key comparer function), automatically rebuilding the cached
 value and key (as done with a simple factory function).
</summary>
</member>
<member name="T:Prime.MutantCache`1">
<summary>
 Presents a purely-functional interface to a mutable object / record / whatever.
 If it is not satisfactorily efficient to run a clone operation on the mutant for every get,
 just pass in the id function for make&apos;s cloneMutant arg, but make sure to NEVER mutate the
 returned mutant!
</summary>
</member>
<member name="T:Prime.HMap`2">
<summary>
 A very fast persistent hash map.
 Works in effectively constant-time for look-ups and updates.
</summary>
</member>
<member name="T:Prime.HSet`1">
<summary>
 A very fast persistent hash set.
 Works in effectively constant-time for look-ups and updates.
</summary>
</member>
<member name="T:Prime.Vsync`1">
<summary>
 The &apos;Vsync&apos; (AKA, &apos;Variable Synchrony&apos;) monad.
 Allows code to run in either an async or synchronous fashion to aid in debugging.
 NOTE: to reference how all this stuff works in F#, see here - https://msdn.microsoft.com/en-us/library/dd233182.aspx
</summary>
</member>
<member name="T:Prime.VsyncBuilder">
<summary>
 The Vsync computation expression builder.
</summary>
</member>
<member name="T:Prime.PropertyMap">
<summary>
 A map of propertyies.
 NOTE: Xtension uses UMap because it&apos;s slightly faster when used in the Nu game engine, but
 it&apos;s not necessarily the right decision in other contexts. However, I&apos;m sticking with this
 choice since the performance of Nu trumps other usages for now.
</summary>
</member>
<member name="T:Prime.DesignerProperty">
<summary>
 A designer-defined property.
</summary>
</member>
<member name="T:Prime.Property">
<summary>
 A vanilla property.
</summary>
</member>
<member name="T:Prime.PropertyDescriptor">
<summary>
 Describes a property.
</summary>
</member>
<member name="M:Prime.PropertyDescription.op_Dynamic``1(``0,System.String)">
<summary>
 Some magic syntax for composing value properties.
</summary>
</member>
<member name="T:Prime.PropertyDescription">
<summary>
 In tandem with the property literal, grants a nice syntax to denote properties.
</summary>
</member>
<member name="M:Prime.VariableDescription.op_Dynamic``2(``0,System.String)">
<summary>
 Some magic syntax for composing variable properties.
</summary>
</member>
<member name="T:Prime.VariableDescription">
<summary>
 In tandem with the variable literal, grants a nice syntax to define variable properties.
</summary>
</member>
<member name="M:Prime.ValueDescription.op_Dynamic``2(``0,System.String)">
<summary>
 Some magic syntax for composing value properties.
</summary>
</member>
<member name="T:Prime.ValueDescription">
<summary>
 In tandem with the define literal, grants a nice syntax to define value properties.
</summary>
</member>
<member name="M:Prime.PropertyDefinition.validate(Prime.PropertyDefinition)">
<summary>
 Validate a property definition.
</summary>
</member>
<member name="M:Prime.PropertyDefinition.makeValidated(System.String,System.Type,Prime.PropertyExpr)">
<summary>
 Make a property definition, validating it in the process.
</summary>
</member>
<member name="M:Prime.PropertyDefinition.make(System.String,System.Type,Prime.PropertyExpr)">
<summary>
 Make a property definition.
</summary>
</member>
<member name="T:Prime.PropertyDefinition">
<summary>
 The definition of a data-driven property.
</summary>
</member>
<member name="M:Prime.PropertyExpr.eval(Prime.PropertyExpr)">
<summary>
 Evaluate a property expression.
</summary>
</member>
<member name="T:Prime.PropertyExpr">
<summary>
 An evaluatable expression for defining a property.
</summary>
</member>
<member name="T:Prime.DefaultValueAttribute">
<summary>
 An attribute to specify the default value of a property.
</summary>
</member>
<member name="T:Prime.SymbolicCompression`2">
<summary>
 Compresses two unions into a single union in a symbolic-expression.
</summary>
</member>
<member name="T:Prime.SymbolicExpansionAttribute">
<summary>
 Expands a record so that its fields are named.
</summary>
</member>
<member name="T:Prime.Mold">
<summary>
 Describes an F# type in a normalized fashion.
</summary>
</member>
<member name="T:Prime.Primitive">
<summary>
 A primitive mold type.
</summary>
</member>
<member name="T:Prime.InstantiationRules">
<summary>
 Describes the means through which member are instantiated.
</summary>
</member>
<member name="T:Prime.InstantiationRule">
<summary>
 Describes the means through which a member is instantiated.
</summary>
</member>
<member name="T:Prime.MemberPath">
<summary>
 Uniquely identifies a type member.
</summary>
</member>
<member name="T:Prime.Molder">
<summary>
 Automatically converts F# types, molds, and instances as customized by user-defined rules.
</summary>
</member>
<member name="T:Prime.UserState">
<summary>
 User-defined state.
</summary>
</member>
<member name="T:Prime.Xtension">
<summary>
 Xtensions (and their supporting types) are a dynamic, functional, and convenient way
 to implement dynamic properties.
</summary>
</member>
<member name="T:Prime.Rexpr">
<summary>
 Effectively new-types the Regex type to implement custom type-conversation without needing
 explicit initialization by the client program.
</summary>
</member>
<member name="T:Prime.RexprConverter">
<summary>
 Converts Rexpr types.
</summary>
</member>
<member name="T:Prime.PropertyTag`3">
<summary>
 Describes a property of a participant.
 Similar to a Haskell lens, but specialized to properties.
</summary>
</member>
<member name="T:Prime.ParticipantChangeData`2">
<summary>
 The data for a change in a participant.
</summary>
</member>
<member name="M:Prime.ParticipantOperators.op_MinusGreaterMinus``1(Prime.AddressModule.Address{``0},Prime.Participant)">
<summary>
 Concatenate two addresses, takings the type of first address.
</summary>
</member>
<member name="M:Prime.ParticipantOperators.acatf``1(Prime.AddressModule.Address{``0},Prime.Participant)">
<summary>
 Concatenate two addresses, forcing the type of first address.
</summary>
</member>
<member name="T:Prime.ParticipantOperators">
<summary>
 Operators for the Participant type.
</summary>
</member>
<member name="T:Prime.Participant">
<summary>
 A participant in the event system.
</summary>
</member>
<member name="T:Prime.EventSystem`1">
<summary>
 A publisher-neutral, purely functional event system.
</summary>
</member>
<member name="T:Prime.UnsubscriptionEntries">
<summary>
 A map of subscription keys to unsubscription data.
</summary>
</member>
<member name="T:Prime.SubscriptionEntries">
<summary>
 A map of event subscriptions.
</summary>
</member>
<member name="T:Prime.BoxableSubscription`1">
<summary>
 Describes an event subscription that can be boxed / unboxed.
</summary>
</member>
<member name="T:Prime.SubscriptionSorter`1">
<summary>
 Abstracts over a subscription sorting procedure.
</summary>
</member>
<member name="T:Prime.Event`2">
<summary>
 An event used by the event system.
</summary>
</member>
<member name="T:Prime.SubscriptionEntry">
<summary>
 An entry in the subscription map.
</summary>
</member>
<member name="T:Prime.Liveness">
<summary>
 Specifies whether an event-based application is running or exiting.
</summary>
</member>
<member name="T:Prime.Handling">
<summary>
 Describes whether an in-flight event has been resolved or should cascade to down-stream handlers.
</summary>
</member>
<member name="T:Prime.EventWorld`2">
<summary>
 The context in which all events take place. Effectively a mix-in for the &apos;w type, where &apos;w is a type that
 represents the client program.
</summary>
</member>
<member name="T:Prime.Stream`3">
<summary>
 A stream in the functional reactive style.
</summary>
</member>
<member name="M:Prime.ChainBuilder.Return``4(``0)">
<summary>
 Monadic return for the chain monad.
</summary>
</member>
<member name="M:Prime.ChainBuilder.Bind``5(Prime.Chain{``0,``1,``2,``3},Microsoft.FSharp.Core.FSharpFunc{``1,Prime.Chain{``0,``4,``2,``3}})">
<summary>
 Monadic bind for the chain monad.
</summary>
</member>
<member name="T:Prime.ChainBuilder">
<summary>
 Implements the chain monad.
</summary>
</member>
<member name="T:Prime.Chain`4">
<summary>
 The Chain monad. Allows the user to define a chain of operations over the world that
 optionally spans across a bounded number of events.

 The following is a potentially tail-recursible representation as speculated by @tpetricek -
 &apos;w -&gt; (&apos;w * Either&lt;&apos;e -&gt; Chain&lt;&apos;e, &apos;a, &apos;g, &apos;w&gt;, &apos;a&gt; -&gt; &apos;a) -&gt; &apos;a
</summary>
</member>
<member name="T:Prime.ScriptingWorld`1">
<summary>
 The context in which scripting takes place. Effectively a mix-in for the &apos;w type, where &apos;w is a type that
 represents the client program.
</summary>
</member>
<member name="M:Prime.Operators.op_Concatenate``2(Microsoft.FSharp.Core.FSharpFunc{``0,``1},``0)">
<summary>
 Sequences two functions like Haskell ($).
</summary>
</member>
<member name="M:Prime.Operators.failwithnie``1">
<summary>
 Fail with a &apos;NotImplementedException&apos;.
</summary>
</member>
<member name="M:Prime.Operators.failwithumf``1">
<summary>
 Fail with an unexpected match failure.
</summary>
</member>
<member name="M:Prime.Operators.makeGuidFromInts(System.Int32,System.Int32)">
<summary>
 Make a Guid from a couple of ints.
 It is the user&apos;s responsibility to ensure uniqueness when using the resulting Guids.
</summary>
</member>
<member name="M:Prime.Operators.makeGuid">
<summary>
 Make a Guid.
</summary>
</member>
<member name="M:Prime.Operators.assignTypeConverter``2">
<summary>
 Add a custom TypeConverter to an existing type.
</summary>
</member>
<member name="M:Prime.Operators.enumerator``1(System.Collections.Generic.IEnumerable{``0})">
<summary>
 Get the enumerator for a sequence.
</summary>
</member>
<member name="M:Prime.Operators.enumerable``1(System.Collections.IEnumerable)">
<summary>
 Short-hand for linq enumerable cast.
</summary>
</member>
<member name="M:Prime.Operators.fastEq``1(``0,``0)">
<summary>
 Test for equality, usually faster than (=).
 TODO: make sure this always generates code equally fast or faster.
</summary>
</member>
<member name="M:Prime.Operators.refEq``1(``0,``0)">
<summary>
 Test for reference equality.
</summary>
</member>
<member name="M:Prime.Operators.strCmp(System.String,System.String)">
<summary>
 Compare two strings.
</summary>
</member>
<member name="M:Prime.Operators.strEq(System.String,System.String)">
<summary>
 Test for string equality.
</summary>
</member>
<member name="M:Prime.Operators.getProperties(System.Type)">
<summary>
 Get the properties of a type.
</summary>
</member>
<member name="M:Prime.Operators.getTypeName``1(``0)">
<summary>
 Get the .NET type name of a target.
</summary>
</member>
<member name="M:Prime.Operators.getType``1(``0)">
<summary>
 Get the .NET type of a target.
</summary>
</member>
<member name="M:Prime.Operators.isNullTrueValue(System.Type)">
<summary>
 Test that the given type has null as an actual value.
</summary>
</member>
<member name="M:Prime.Operators.isNotNull``1(``0)">
<summary>
 Test for non-null.
</summary>
</member>
<member name="M:Prime.Operators.isNull``1(``0)">
<summary>
 Test for null.
</summary>
</member>
<member name="M:Prime.Operators.flip4``5(Microsoft.FSharp.Core.FSharpFunc{``0,Microsoft.FSharp.Core.FSharpFunc{``1,Microsoft.FSharp.Core.FSharpFunc{``2,Microsoft.FSharp.Core.FSharpFunc{``3,``4}}}},``1,``2,``3,``0)">
<summary>
 Transforms a function by flipping the order of its arguments.
</summary>
</member>
<member name="M:Prime.Operators.flip3``4(Microsoft.FSharp.Core.FSharpFunc{``0,Microsoft.FSharp.Core.FSharpFunc{``1,Microsoft.FSharp.Core.FSharpFunc{``2,``3}}},``1,``2,``0)">
<summary>
 Transforms a function by flipping the order of its arguments.
</summary>
</member>
<member name="M:Prime.Operators.flip``3(Microsoft.FSharp.Core.FSharpFunc{``0,Microsoft.FSharp.Core.FSharpFunc{``1,``2}},``1,``0)">
<summary>
 Transforms a function by flipping the order of its arguments.
</summary>
</member>
<member name="M:Prime.Operators.uncurry``3(Microsoft.FSharp.Core.FSharpFunc{``0,Microsoft.FSharp.Core.FSharpFunc{``1,``2}},``0,``1)">
<summary>
 Uncurry two values.
</summary>
</member>
<member name="M:Prime.Operators.curry``3(Microsoft.FSharp.Core.FSharpFunc{System.Tuple{``0,``1},``2},``0,``1)">
<summary>
 Curry up two values.
</summary>
</member>
<member name="M:Prime.Operators.absurdity2``2(``0,``1)">
<summary>
 The absurdity function with two arguments.
 No matter what you pass it, it evaluates to false.
</summary>
</member>
<member name="M:Prime.Operators.absurdity``1(``0)">
<summary>
 The absurdity function.
 No matter what you pass it, it evaluates to false.
</summary>
</member>
<member name="M:Prime.Operators.tautology3``3(``0,``1,``2)">
<summary>
 The tautology function with three arguments.
 No matter what you pass it, it evaluates to true.
</summary>
</member>
<member name="M:Prime.Operators.tautology2``2(``0,``1)">
<summary>
 The tautology function with two arguments.
 No matter what you pass it, it evaluates to true.
</summary>
</member>
<member name="M:Prime.Operators.tautology``1(``0)">
<summary>
 The tautology function.
 No matter what you pass it, it evaluates to true.
</summary>
</member>
<member name="M:Prime.Operators.constant``2(``0,``1)">
<summary>
 The constant function.
 No matter what you pass it, it evaluates to a constant value.
</summary>
</member>
<member name="M:Prime.Generics.div``3(``0,``1)">
<summary>
 Generic (and sectioned) division.
</summary>
</member>
<member name="M:Prime.Generics.mul``3(``0,``1)">
<summary>
 Generic (and sectioned) multiplication.
</summary>
</member>
<member name="M:Prime.Generics.sub``3(``0,``1)">
<summary>
 Generic (and sectioned) subtraction.
</summary>
</member>
<member name="M:Prime.Generics.add``3(``0,``1)">
<summary>
 Generic (and sectioned) addition.
</summary>
</member>
<member name="M:Prime.Generics.dec``3(``0)">
<summary>
 Generic (and sectioned) decrement.
</summary>
</member>
<member name="M:Prime.Generics.inc``3(``0)">
<summary>
 Generic (and sectioned) increment.
</summary>
</member>
<member name="M:Prime.Generics.append``3(``0,``1)">
<summary>
 The generic monoidal append operation.
</summary>
</member>
<member name="M:Prime.Generics.empty``1">
<summary>
 The generic monoidal empty value.
</summary>
</member>
<member name="M:Prime.Generics.one``1">
<summary>
 The generic one value.
</summary>
</member>
<member name="M:Prime.Generics.zero``1">
<summary>
 The generic zero value.
</summary>
</member>
<member name="M:Prime.Log.init(Microsoft.FSharp.Core.FSharpOption{System.String})">
<summary>
 Initialize logging.
</summary>
</member>
<member name="M:Prime.Log.traceIf(System.Boolean,System.String)">
<summary>
 Conditional trace message call where condition is eagerly evaluted.
</summary>
</member>
<member name="M:Prime.Log.trace(System.String)">
<summary>
 Log a trace message using Trace.Fail and call to info.
</summary>
</member>
<member name="M:Prime.Log.debugIf(Microsoft.FSharp.Core.FSharpFunc{Microsoft.FSharp.Core.Unit,System.Boolean},System.String)">
<summary>
 Conditional debug message call where condition is lazily evaluated.
</summary>
</member>
<member name="M:Prime.Log.debug(System.String)">
<summary>
 Log a debug message with Debug.Fail and call to info.
</summary>
</member>
<member name="M:Prime.Log.info(System.String)">
<summary>
 Log a purely informational message using Trace.WriteLine.
</summary>
</member>
<member name="M:Prime.Log.remark(System.String,System.String)">
<summary>
 Log a remark with a custom header using Trace.WriteLine.
</summary>
</member>
<member name="M:Prime.Option.mapOrDefault``2(Microsoft.FSharp.Core.FSharpFunc{``0,``1},``1,Microsoft.FSharp.Core.FSharpOption{``0})">
<summary>
 Map an option&apos;s value, or missing that, return a default value.
</summary>
</member>
<member name="M:Prime.Option.getOrDefault``1(``0,Microsoft.FSharp.Core.FSharpOption{``0})">
<summary>
 Get an option&apos;s value, or missing that, return a default value.
</summary>
</member>
<member name="M:Prime.Option.flatten``1(Microsoft.FSharp.Core.FSharpOption{Microsoft.FSharp.Core.FSharpOption{``0}})">
<summary>
 Flatten an option option.
</summary>
</member>
<member name="M:Prime.Pair.make``2(``0,``1)">
<summary>
 Make a pair.
</summary>
</member>
<member name="M:Prime.PairOperators.mapSnd``3(Microsoft.FSharp.Core.FSharpFunc{``0,``1},``2,``0)">
<summary>
 Map over pair member snd.
</summary>
</member>
<member name="M:Prime.PairOperators.mapFst``3(Microsoft.FSharp.Core.FSharpFunc{``0,``1},``0,``2)">
<summary>
 Map over pair member fst.
</summary>
</member>
<member name="M:Prime.PairOperators.withSnd``3(``0,``1,``2)">
<summary>
 Replace pair member snd.
</summary>
</member>
<member name="M:Prime.PairOperators.withFst``3(``0,``1,``2)">
<summary>
 Replace pair member fst.
</summary>
</member>
<member name="M:Prime.PairStruct.make``2(``0,``1)">
<summary>
 Make a pair.
</summary>
</member>
<member name="M:Prime.PairStructOperators.mapSnd'``3(Microsoft.FSharp.Core.FSharpFunc{``0,``1},System.ValueTuple{``2,``0})">
<summary>
 Map over struct pair member snd.
</summary>
</member>
<member name="M:Prime.PairStructOperators.mapFst'``3(Microsoft.FSharp.Core.FSharpFunc{``0,``1},System.ValueTuple{``0,``2})">
<summary>
 Map over struct pair member fst.
</summary>
</member>
<member name="M:Prime.PairStructOperators.withSnd'``3(``0,System.ValueTuple{``1,``2})">
<summary>
 Replace struct pair member snd.
</summary>
</member>
<member name="M:Prime.PairStructOperators.withFst'``3(``0,System.ValueTuple{``1,``2})">
<summary>
 Replace struct pair member fst.
</summary>
</member>
<member name="M:Prime.PairStructOperators.snd'``2(System.ValueTuple{``0,``1})">
<summary>
 Get the snd value in a struct pair.
</summary>
</member>
<member name="M:Prime.PairStructOperators.fst'``2(System.ValueTuple{``0,``1})">
<summary>
 Get the fst value in a struct pair.
</summary>
</member>
<member name="M:Prime.Triple.make``3(``0,``1,``2)">
<summary>
 Make a triple.
</summary>
</member>
<member name="M:Prime.Triple.mapC``4(Microsoft.FSharp.Core.FSharpFunc{``0,``1},``2,``3,``0)">
<summary>
 Map over triple member c.
</summary>
</member>
<member name="M:Prime.Triple.mapB``4(Microsoft.FSharp.Core.FSharpFunc{``0,``1},``2,``0,``3)">
<summary>
 Map over triple member b.
</summary>
</member>
<member name="M:Prime.Triple.mapA``4(Microsoft.FSharp.Core.FSharpFunc{``0,``1},``0,``2,``3)">
<summary>
 Map over triple member a.
</summary>
</member>
<member name="M:Prime.Triple.withC``4(``0,``1,``2,``3)">
<summary>
 Replace triple member c.
</summary>
</member>
<member name="M:Prime.Triple.withB``4(``0,``1,``2,``3)">
<summary>
 Replace triple member b.
</summary>
</member>
<member name="M:Prime.Triple.withA``4(``0,``1,``2,``3)">
<summary>
 Replace triple member a.
</summary>
</member>
<member name="M:Prime.Triple.append``3(``0,``1,``2)">
<summary>
 Append an item to a pair to build a triple.
</summary>
</member>
<member name="M:Prime.Triple.insert``3(``0,``1,``2)">
<summary>
 Insert an item in a pair to build a triple.
</summary>
</member>
<member name="M:Prime.Triple.prepend``3(``0,``1,``2)">
<summary>
 Prepend an item to a pair to build a triple.
</summary>
</member>
<member name="M:Prime.Triple.thd``3">
<summary>
 The third item in a triple.
</summary>
</member>
<member name="M:Prime.Triple.snd``3">
<summary>
 The second item in a triple.
</summary>
</member>
<member name="M:Prime.Triple.fst``3">
<summary>
 The first item in a triple.
</summary>
</member>
<member name="M:Prime.TripleOperators._bc``3(``0,``1,``2)">
<summary>
 The second and third items in a triple.
</summary>
</member>
<member name="M:Prime.TripleOperators.a_c``3(``0,``1,``2)">
<summary>
 The first and third items in a triple.
</summary>
</member>
<member name="M:Prime.TripleOperators.ab_``3(``0,``1,``2)">
<summary>
 The first and second items in a triple.
</summary>
</member>
<member name="M:Prime.TripleOperators.__c``3(``0,``1,``2)">
<summary>
 The third item in a triple.
</summary>
</member>
<member name="M:Prime.TripleOperators._b_``3(``0,``1,``2)">
<summary>
 The second item in a triple.
</summary>
</member>
<member name="M:Prime.TripleOperators.a__``3(``0,``1,``2)">
<summary>
 The first item in a triple.
</summary>
</member>
<member name="M:Prime.Either.ambBy``3(Microsoft.FSharp.Core.FSharpFunc{``0,``1},Microsoft.FSharp.Core.FSharpFunc{``2,``1},Prime.Either{``2,``0})">
<summary>
 Pick whichever of the eir values exists.
</summary>
</member>
<member name="M:Prime.Either.amb``1(Prime.Either{``0,``0})">
<summary>
 Pick whichever of the eir values exists so long as they are the same type.
</summary>
</member>
<member name="M:Prime.Either.split``2(System.Collections.Generic.IEnumerable{Prime.Either{``0,``1}})">
<summary>
 Split a sequences of Either values into a pair of left and right value lists.
</summary>
</member>
<member name="M:Prime.Either.mapRight``3(Microsoft.FSharp.Core.FSharpFunc{``0,``1},Prime.Either{``2,``0})">
<summary>
 Map over the right side of an Either value.
</summary>
</member>
<member name="M:Prime.Either.mapLeft``3(Microsoft.FSharp.Core.FSharpFunc{``0,``1},Prime.Either{``0,``2})">
<summary>
 Map over the left side of an Either value.
</summary>
</member>
<member name="M:Prime.Either.getRightValues``2(System.Collections.Generic.IEnumerable{Prime.Either{``0,``1}})">
<summary>
 Get only the Right values of a sequence of an Either value.
</summary>
</member>
<member name="M:Prime.Either.getLeftValues``2(System.Collections.Generic.IEnumerable{Prime.Either{``0,``1}})">
<summary>
 Get only the Left values of a sequence of an Either value.
</summary>
</member>
<member name="M:Prime.Either.getRightValue``2(Prime.Either{``0,``1})">
<summary>
 Get the Right value of an Either value, failing if not available.
</summary>
</member>
<member name="M:Prime.Either.getLeftValue``2(Prime.Either{``0,``1})">
<summary>
 Get the Left value of an Either value, failing if not available.
</summary>
</member>
<member name="M:Prime.Either.isRight``2(Prime.Either{``0,``1})">
<summary>
 Query whether an Either value is a Right value.
</summary>
</member>
<member name="M:Prime.Either.isLeft``2(Prime.Either{``0,``1})">
<summary>
 Query whether an Either value is a Left value.
</summary>
</member>
<member name="M:Prime.Either.bind``3(Prime.Either{``0,``1},Microsoft.FSharp.Core.FSharpFunc{``1,Prime.Either{``0,``2}})">
<summary>
 Monadic bind for Either.
</summary>
</member>
<member name="M:Prime.Either.returnFrom``1(``0)">
<summary>
 Monadic &apos;return from&apos; for Either.
</summary>
</member>
<member name="M:Prime.Either.returnM``2(``0)">
<summary>
 Monadic return for Either.
</summary>
</member>
<member name="P:Prime.EitherBuilderModule.either">
<summary>
 Builds the either monad.
</summary>
</member>
<member name="M:Prime.Seq.split``1(Microsoft.FSharp.Core.FSharpFunc{``0,System.Boolean},System.Collections.Generic.IEnumerable{``0})">
<summary>
 Split a sequence on a predicate.
</summary>
</member>
<member name="M:Prime.Seq.notExists``1(Microsoft.FSharp.Core.FSharpFunc{``0,System.Boolean},System.Collections.Generic.IEnumerable{``0})">
<summary>
 Check that a predicate passes for NO items in a sequence.
</summary>
</member>
<member name="M:Prime.Seq.foldUntilRight``3(Microsoft.FSharp.Core.FSharpFunc{``0,Microsoft.FSharp.Core.FSharpFunc{``1,Prime.Either{``0,``2}}},Prime.Either{``0,``2},System.Collections.Generic.IEnumerable{``1})">
<summary>
 Implement a fold until folder results in Right.
</summary>
</member>
<member name="M:Prime.Seq.foldUntil``2(Microsoft.FSharp.Core.FSharpFunc{``0,Microsoft.FSharp.Core.FSharpFunc{``1,Microsoft.FSharp.Core.FSharpOption{``0}}},``0,System.Collections.Generic.IEnumerable{``1})">
<summary>
 Implement a fold until folder results in Some.
</summary>
</member>
<member name="M:Prime.Seq.foldWhileRight``3(Microsoft.FSharp.Core.FSharpFunc{``0,Microsoft.FSharp.Core.FSharpFunc{``1,Prime.Either{``2,``0}}},Prime.Either{``2,``0},System.Collections.Generic.IEnumerable{``1})">
<summary>
 Implement a fold while folder results in Right.
</summary>
</member>
<member name="M:Prime.Seq.foldWhile``2(Microsoft.FSharp.Core.FSharpFunc{``0,Microsoft.FSharp.Core.FSharpFunc{``1,Microsoft.FSharp.Core.FSharpOption{``0}}},``0,System.Collections.Generic.IEnumerable{``1})">
<summary>
 Implement a fold while folder results in Some.
</summary>
</member>
<member name="M:Prime.Seq.project``2(Microsoft.FSharp.Core.FSharpFunc{Microsoft.FSharp.Core.FSharpOption{``0},Microsoft.FSharp.Core.FSharpOption{``1}},System.Collections.Generic.IEnumerable{``1},System.Collections.Generic.IEnumerable{Microsoft.FSharp.Core.FSharpOption{``0}})">
<summary>
 Project the first sequence onto the second.
</summary>
</member>
<member name="M:Prime.Seq.trySkip``1(System.Int32,System.Collections.Generic.IEnumerable{``0})">
<summary>
 A more tolerant and open-minded skip.
</summary>
</member>
<member name="M:Prime.Seq.tryTake``1(System.Int32,System.Collections.Generic.IEnumerable{``0})">
<summary>
 A more tolerant and open-minded take.
</summary>
</member>
<member name="M:Prime.Seq.fornone``1(Microsoft.FSharp.Core.FSharpFunc{``0,System.Boolean},System.Collections.Generic.IEnumerable{``0})">
<summary>
 Check if no items satisfy a predicate in a seq.
</summary>
</member>
<member name="M:Prime.Seq.foldBack``2(Microsoft.FSharp.Core.FSharpFunc{``0,Microsoft.FSharp.Core.FSharpFunc{``1,``1}},System.Collections.Generic.IEnumerable{``0},``1)">
<summary>
 Fold-back for seqs.
</summary>
</member>
<member name="M:Prime.Seq.foldi``2(Microsoft.FSharp.Core.FSharpFunc{System.Int32,Microsoft.FSharp.Core.FSharpFunc{``0,Microsoft.FSharp.Core.FSharpFunc{``1,``0}}},``0,System.Collections.Generic.IEnumerable{``1})">
<summary>
 Fold, now with a counter!
</summary>
</member>
<member name="M:Prime.Seq.fold2``3(Microsoft.FSharp.Core.FSharpFunc{``0,Microsoft.FSharp.Core.FSharpFunc{``1,Microsoft.FSharp.Core.FSharpFunc{``2,``0}}},``0,System.Collections.Generic.IEnumerable{``1},System.Collections.Generic.IEnumerable{``2})">
<summary>
 Fold with two inputs (plus state).
</summary>
</member>
<member name="M:Prime.Seq.definitizePlus``1(System.Collections.Generic.IEnumerable{Microsoft.FSharp.Core.FSharpOption{``0}})">
<summary>
 Convert option values to definite values, returning an additional flag to indicate that all values were some.
</summary>
</member>
<member name="M:Prime.Seq.definitize``1(System.Collections.Generic.IEnumerable{Microsoft.FSharp.Core.FSharpOption{``0}})">
<summary>
 Convert option values to definite values.
</summary>
</member>
<member name="M:Prime.Seq.headOrDefault``1(System.Collections.Generic.IEnumerable{``0},Microsoft.FSharp.Core.FSharpOption{``0})">
<summary>
 Get a seq head or a default value if there is none.
</summary>
</member>
<member name="M:Prime.Seq.tryHead``1(System.Collections.Generic.IEnumerable{``0})">
<summary>
 Get Some head of the seq or None.
</summary>
</member>
<member name="M:Prime.Seq.notEmpty``1(System.Collections.Generic.IEnumerable{``0})">
<summary>
 Check that a sequence is not empty.
</summary>
</member>
<member name="M:Prime.Array.sortStable``1(``0[])">
<summary>
 Perform a sort on elements, preserving order of equal elements.
</summary>
</member>
<member name="M:Prime.Array.sortStableBy``2(Microsoft.FSharp.Core.FSharpFunc{``0,``1},``0[])">
<summary>
 Perform a sort on elements, preserving order of equal elements.
</summary>
</member>
<member name="M:Prime.Array.sortStableWith``1(Microsoft.FSharp.Core.FSharpFunc{``0,Microsoft.FSharp.Core.FSharpFunc{``0,System.Int32}},``0[])">
<summary>
 Perform a sort on elements, preserving order of equal elements.
</summary>
</member>
<member name="M:Prime.Array.trySkip``1(System.Int32,``0[])">
<summary>
 A more tolerant and open-minded skip.
</summary>
</member>
<member name="M:Prime.Array.tryTake``1(System.Int32,``0[])">
<summary>
 A more tolerant and open-minded take.
</summary>
</member>
<member name="M:Prime.Array.allButLast``1(``0[])">
<summary>
 Get all but the last item from a list.
</summary>
</member>
<member name="M:Prime.Array.definitizePlus``1(Microsoft.FSharp.Core.FSharpOption{``0}[])">
<summary>
 Convert option values to definite values, returning an additional flag to indicate that all values were some.
</summary>
</member>
<member name="M:Prime.Array.definitize``1(Microsoft.FSharp.Core.FSharpOption{``0}[])">
<summary>
 Convert option values to definite values.
</summary>
</member>
<member name="M:Prime.Array.notExists``1(Microsoft.FSharp.Core.FSharpFunc{``0,System.Boolean},``0[])">
<summary>
 Check that a predicate passes for NO items in an array.
</summary>
</member>
<member name="M:Prime.Array.notEmpty``1(``0[])">
<summary>
 Check that an array is not empty.
</summary>
</member>
<member name="M:Prime.Array.foldUntilRight``3(Microsoft.FSharp.Core.FSharpFunc{``0,Microsoft.FSharp.Core.FSharpFunc{``1,Prime.Either{``0,``2}}},Prime.Either{``0,``2},``1[])">
<summary>
 Implement a fold until folder results in Right.
</summary>
</member>
<member name="M:Prime.Array.foldUntil``2(Microsoft.FSharp.Core.FSharpFunc{``0,Microsoft.FSharp.Core.FSharpFunc{``1,Microsoft.FSharp.Core.FSharpOption{``0}}},``0,``1[])">
<summary>
 Implement a fold until folder results in Nome.
</summary>
</member>
<member name="M:Prime.Array.foldWhileRight``3(Microsoft.FSharp.Core.FSharpFunc{``0,Microsoft.FSharp.Core.FSharpFunc{``1,Prime.Either{``2,``0}}},Prime.Either{``2,``0},``1[])">
<summary>
 Implement a fold while folder results in Right.
</summary>
</member>
<member name="M:Prime.Array.foldWhile``2(Microsoft.FSharp.Core.FSharpFunc{``0,Microsoft.FSharp.Core.FSharpFunc{``1,Microsoft.FSharp.Core.FSharpOption{``0}}},``0,``1[])">
<summary>
 Implement a fold while folder results in Some.
</summary>
</member>
<member name="M:Prime.Array.remove``1(Microsoft.FSharp.Core.FSharpFunc{``0,System.Boolean},``0[])">
<summary>
 Remove the first matching element of the array.
</summary>
</member>
<member name="M:Prime.Array.add``2(``0,``1[])">
<summary>
 Add a value to the end of an array.
</summary>
</member>
<member name="M:Prime.Array.cons``2(``0,``1[])">
<summary>
 Add a value to the front of an array.
</summary>
</member>
<member name="M:Prime.String.hashMany(Microsoft.FSharp.Collections.FSharpList{System.String})">
<summary>
 Hash a list of names.
</summary>
</member>
<member name="M:Prime.String.compareMany(Microsoft.FSharp.Collections.FSharpList{System.String},Microsoft.FSharp.Collections.FSharpList{System.String})">
<summary>
 Compare a list of string lexicographically.
</summary>
</member>
<member name="M:Prime.String.equateMany(Microsoft.FSharp.Collections.FSharpList{System.String},Microsoft.FSharp.Collections.FSharpList{System.String})">
<summary>
 Query for equality a list of string lexicographically.
</summary>
</member>
<member name="M:Prime.String.endsWithGuid(System.String)">
<summary>
 Check that a name ends with a Guid.
</summary>
</member>
<member name="M:Prime.String.escape(System.String)">
<summary>
 Expand escaped characters in a string.
</summary>
</member>
<member name="M:Prime.String.unescape(System.String)">
<summary>
 Contract escaped characters in a string.
</summary>
</member>
<member name="M:Prime.String.surround(System.String,System.String)">
<summary>
 Surround a string with another surrounding string.
</summary>
</member>
<member name="M:Prime.String.toArray(System.String)">
<summary>
 Convert a string to an array of characters.
</summary>
</member>
<member name="M:Prime.String.withEnd(System.String,System.String)">
<summary>
 Get the string with the given ending.
</summary>
</member>
<member name="M:Prime.String.textualize(System.String)">
<summary>
 Textualize a string for usage as text.
</summary>
</member>
<member name="M:Prime.String.capitalize(System.String)">
<summary>
 Capitalize a string.
</summary>
</member>
<member name="M:Prime.String.implode(Microsoft.FSharp.Collections.FSharpList{System.Char})">
<summary>
 Converts a list of characters into a string.
</summary>
</member>
<member name="M:Prime.String.explode(System.String)">
<summary>
 Converts a string into a list of characters.
</summary>
</member>
<member name="M:Prime.String.numberToCodeString(System.Object)">
<summary>
 Convert a number to a string that works well in code.
</summary>
</member>
<member name="M:Prime.String.doubleToCodeString(System.Double)">
<summary>
 Convert a double to a string that works well in code.
</summary>
</member>
<member name="M:Prime.String.singleToCodeString(System.Single)">
<summary>
 Convert a single to a string that works well in code.
</summary>
</member>
<member name="M:Prime.String.int64ToCodeString(System.Int64)">
<summary>
 Convert an int64 to a string that works well in code.
</summary>
</member>
<member name="M:Prime.String.boolToCodeString(System.Boolean)">
<summary>
 Convert a bool to a string that works well in code.
</summary>
</member>
<member name="M:Prime.String.isGuid(System.String)">
<summary>
 Check that a string is a guid.
</summary>
</member>
<member name="M:Prime.String.notEmpty(System.String)">
<summary>
 Check that a string is not empty.
</summary>
</member>
<member name="M:Prime.String.isEmpty(System.String)">
<summary>
 Check that a string is empty.
</summary>
</member>
<member name="M:Prime.List.hash``1(Microsoft.FSharp.Collections.FSharpList{``0})">
<summary>
 Hash a list.
 NOTE: May be a pessimization.
</summary>
</member>
<member name="M:Prime.List.containsTriplicates``1(Microsoft.FSharp.Collections.FSharpList{``0})">
<summary>
 Check that a list contains triplicate entries.
</summary>
</member>
<member name="M:Prime.List.containsDuplicates``1(Microsoft.FSharp.Collections.FSharpList{``0})">
<summary>
 Check that a list contains duplicate entries.
 O(n^2) complexity, but does not allocate.
</summary>
</member>
<member name="M:Prime.List.compareStrings(Microsoft.FSharp.Collections.FSharpList{System.String},Microsoft.FSharp.Collections.FSharpList{System.String})">
<summary>
 Compare a list of strings lexicographically.
</summary>
</member>
<member name="M:Prime.List.power``1(Microsoft.FSharp.Collections.FSharpList{``0})">
<summary>
 Compute the &apos;power set&apos; of a list.
 Example - [0, 1, 2] becomes [[]; [0]; [0; 1]; [0; 1; 2]]
</summary>
</member>
<member name="M:Prime.List.remove``1(Microsoft.FSharp.Core.FSharpFunc{``0,System.Boolean},Microsoft.FSharp.Collections.FSharpList{``0})">
<summary>
 Remove all items from a list that satisfy a predicate.
</summary>
</member>
<member name="M:Prime.List.split``1(Microsoft.FSharp.Core.FSharpFunc{``0,System.Boolean},Microsoft.FSharp.Collections.FSharpList{``0})">
<summary>
 Split a list on a predicate.
</summary>
</member>
<member name="M:Prime.List.notExists``1(Microsoft.FSharp.Core.FSharpFunc{``0,System.Boolean},Microsoft.FSharp.Collections.FSharpList{``0})">
<summary>
 Check that a predicate passes for NO items in a list.
</summary>
</member>
<member name="M:Prime.List.foldUntilRight``3(Microsoft.FSharp.Core.FSharpFunc{``0,Microsoft.FSharp.Core.FSharpFunc{``1,Prime.Either{``0,``2}}},Prime.Either{``0,``2},Microsoft.FSharp.Collections.FSharpList{``1})">
<summary>
 Implement a fold until folder results in Right.
</summary>
</member>
<member name="M:Prime.List.foldUntil``2(Microsoft.FSharp.Core.FSharpFunc{``0,Microsoft.FSharp.Core.FSharpFunc{``1,Microsoft.FSharp.Core.FSharpOption{``0}}},``0,Microsoft.FSharp.Collections.FSharpList{``1})">
<summary>
 Implement a fold until folder results in Nome.
</summary>
</member>
<member name="M:Prime.List.foldWhileRight``3(Microsoft.FSharp.Core.FSharpFunc{``0,Microsoft.FSharp.Core.FSharpFunc{``1,Prime.Either{``2,``0}}},Prime.Either{``2,``0},Microsoft.FSharp.Collections.FSharpList{``1})">
<summary>
 Implement a fold while folder results in Right.
</summary>
</member>
<member name="M:Prime.List.foldWhile``2(Microsoft.FSharp.Core.FSharpFunc{``0,Microsoft.FSharp.Core.FSharpFunc{``1,Microsoft.FSharp.Core.FSharpOption{``0}}},``0,Microsoft.FSharp.Collections.FSharpList{``1})">
<summary>
 Implement a fold while folder results in Some.
</summary>
</member>
<member name="M:Prime.List.toHashSet``1(Microsoft.FSharp.Collections.FSharpList{``0})">
<summary>
 Convert a list to a HashSet.
</summary>
</member>
<member name="M:Prime.List.toDictBy``3(Microsoft.FSharp.Core.FSharpFunc{``0,System.Tuple{``1,``2}},Microsoft.FSharp.Collections.FSharpList{``0})">
<summary>
 Convert a list of values to a Dictionary.
</summary>
</member>
<member name="M:Prime.List.toDict``2(Microsoft.FSharp.Collections.FSharpList{System.Tuple{``0,``1}})">
<summary>
 Convert a list of pairs to a Dictionary.
</summary>
</member>
<member name="M:Prime.List.addToDictBy``3(Microsoft.FSharp.Core.FSharpFunc{``0,System.Tuple{``1,``2}},System.Collections.Generic.Dictionary{``1,``2},Microsoft.FSharp.Collections.FSharpList{``0})">
<summary>
 Add a list of values to a Dictionary.
</summary>
</member>
<member name="M:Prime.List.addToDict``2(System.Collections.Generic.Dictionary{``0,``1},Microsoft.FSharp.Collections.FSharpList{System.Tuple{``0,``1}})">
<summary>
 Add a list of pairs to a Dictionary.
</summary>
</member>
<member name="M:Prime.List.intersect``1(Microsoft.FSharp.Collections.FSharpList{``0},Microsoft.FSharp.Collections.FSharpList{``0})">
<summary>
 Get the set interesection of two lists.
</summary>
</member>
<member name="M:Prime.List.isSuperset``1(Microsoft.FSharp.Collections.FSharpList{``0},Microsoft.FSharp.Collections.FSharpList{``0})">
<summary>
 Check that the first list a superset of the second list.
</summary>
</member>
<member name="M:Prime.List.isSubset``1(Microsoft.FSharp.Collections.FSharpList{``0},Microsoft.FSharp.Collections.FSharpList{``0})">
<summary>
 Check that the first list a subset of the second list.
</summary>
</member>
<member name="M:Prime.List.setBinop``3(Microsoft.FSharp.Core.FSharpFunc{Microsoft.FSharp.Collections.FSharpSet{``0},Microsoft.FSharp.Core.FSharpFunc{Microsoft.FSharp.Collections.FSharpSet{``1},``2}},Microsoft.FSharp.Collections.FSharpList{``0},Microsoft.FSharp.Collections.FSharpList{``1})">
<summary>
 Runs a binary set operation on two lists that are converted to sets.
</summary>
</member>
<member name="M:Prime.List.takeTillInclusive``1(Microsoft.FSharp.Core.FSharpFunc{``0,System.Boolean},Microsoft.FSharp.Collections.FSharpList{``0})">
<summary>
 Take items until an item satisfies a predicate, taking also that element.
</summary>
</member>
<member name="M:Prime.List.joinMany``1(Microsoft.FSharp.Collections.FSharpList{``0},Microsoft.FSharp.Collections.FSharpList{Microsoft.FSharp.Collections.FSharpList{``0}})">
<summary>
 Join a list of lists into a list separated by sep.
</summary>
</member>
<member name="M:Prime.List.joinBy``1(Microsoft.FSharp.Core.FSharpFunc{``0,System.String},System.String,Microsoft.FSharp.Collections.FSharpList{``0})">
<summary>
 Join a list into a string separated by sep.
 TODO: consider optimizing with a StringBuilder.
</summary>
</member>
<member name="M:Prime.List.join(System.String,Microsoft.FSharp.Collections.FSharpList{System.String})">
<summary>
 Join a list into a string separated by sep.
</summary>
</member>
<member name="M:Prime.List.padWithLastToProportion``2(Microsoft.FSharp.Collections.FSharpList{``0},Microsoft.FSharp.Collections.FSharpList{``1})">
<summary>
 Pad a list with instances of its last item so that it is proportion to another list.
</summary>
</member>
<member name="M:Prime.List.padWithLast``1(System.Int32,Microsoft.FSharp.Collections.FSharpList{``0})">
<summary>
 Pad a list with count instances of its last item.
</summary>
</member>
<member name="M:Prime.List.pad``1(System.Int32,``0,Microsoft.FSharp.Collections.FSharpList{``0})">
<summary>
 Pad a list with count instances of its last item, removing items from back if count is negative.
</summary>
</member>
<member name="M:Prime.List.resize``1(System.Int32,``0,Microsoft.FSharp.Collections.FSharpList{``0})">
<summary>
 Resize a list with the given elem for expanded elements.
</summary>
</member>
<member name="M:Prime.List.allOrEmptyBy``2(Microsoft.FSharp.Core.FSharpFunc{``0,Microsoft.FSharp.Core.FSharpOption{``1}},Microsoft.FSharp.Collections.FSharpList{``0})">
<summary>
 Make a transformed list of options an all or nothing proposition.
</summary>
</member>
<member name="M:Prime.List.allOrEmpty``1(Microsoft.FSharp.Collections.FSharpList{Microsoft.FSharp.Core.FSharpOption{``0}})">
<summary>
 Make a list of options an all or nothing proposition.
</summary>
</member>
<member name="M:Prime.List.definitizePlus``1(Microsoft.FSharp.Collections.FSharpList{Microsoft.FSharp.Core.FSharpOption{``0}})">
<summary>
 Convert option values to definite values, returning an additional flag to indicate that all value were some.
</summary>
</member>
<member name="M:Prime.List.definitize``1(Microsoft.FSharp.Collections.FSharpList{Microsoft.FSharp.Core.FSharpOption{``0}})">
<summary>
 Convert option values to definite values.
</summary>
</member>
<member name="M:Prime.List.allButLast``1(Microsoft.FSharp.Collections.FSharpList{``0})">
<summary>
 Get all but the last item from a list.
</summary>
</member>
<member name="M:Prime.List.foldi``2(Microsoft.FSharp.Core.FSharpFunc{System.Int32,Microsoft.FSharp.Core.FSharpFunc{``0,Microsoft.FSharp.Core.FSharpFunc{``1,``0}}},``0,Microsoft.FSharp.Collections.FSharpList{``1})">
<summary>
 Foldi for lists.
</summary>
</member>
<member name="M:Prime.List.fornone``1(Microsoft.FSharp.Core.FSharpFunc{``0,System.Boolean},Microsoft.FSharp.Collections.FSharpList{``0})">
<summary>
 Fornone for lists.
</summary>
</member>
<member name="M:Prime.List.replaceHead``1(Microsoft.FSharp.Collections.FSharpList{``0},``0)">
<summary>
 Replace a list&apos;s head.
</summary>
</member>
<member name="M:Prime.List.project``2(Microsoft.FSharp.Core.FSharpFunc{Microsoft.FSharp.Core.FSharpOption{``0},Microsoft.FSharp.Core.FSharpOption{``1}},Microsoft.FSharp.Collections.FSharpList{``1},Microsoft.FSharp.Collections.FSharpList{Microsoft.FSharp.Core.FSharpOption{``0}})">
<summary>
 Project the first list onto the second.
</summary>
</member>
<member name="M:Prime.List.trySkip``1(System.Int32,Microsoft.FSharp.Collections.FSharpList{``0})">
<summary>
 A more tolerant and open-minded skip.
</summary>
</member>
<member name="M:Prime.List.tryTake``1(System.Int32,Microsoft.FSharp.Collections.FSharpList{``0})">
<summary>
 A more tolerant and open-minded take.
</summary>
</member>
<member name="M:Prime.List.zipBy``3(Microsoft.FSharp.Core.FSharpFunc{System.Tuple{``0,``1},``2},Microsoft.FSharp.Collections.FSharpList{``0},Microsoft.FSharp.Collections.FSharpList{``1})">
<summary>
 Zip two lists by a function.
</summary>
</member>
<member name="M:Prime.List.roll``2(Microsoft.FSharp.Core.FSharpFunc{``0,Microsoft.FSharp.Core.FSharpFunc{``1,Microsoft.FSharp.Core.FSharpFunc{``1,``0}}},``0,Microsoft.FSharp.Collections.FSharpList{``1})">
<summary>
 Threads a computation state through the adjacent members of a list.
</summary>
</member>
<member name="M:Prime.List.forall2Plus``2(Microsoft.FSharp.Core.FSharpFunc{``0,Microsoft.FSharp.Core.FSharpFunc{``1,System.Boolean}},Microsoft.FSharp.Collections.FSharpList{``0},Microsoft.FSharp.Collections.FSharpList{``1})">
<summary>
 For all 2 that indicates uneven lists by returning false rather than raising.
</summary>
</member>
<member name="M:Prime.List.tryFindAt``1(System.Int32,Microsoft.FSharp.Collections.FSharpList{``0})">
<summary>
 Try to find a value at index n.
</summary>
</member>
<member name="M:Prime.List.tryFindPlus``2(Microsoft.FSharp.Core.FSharpFunc{``0,Microsoft.FSharp.Core.FSharpOption{``1}},Microsoft.FSharp.Collections.FSharpList{``0})">
<summary>
 Try to find a value.
</summary>
</member>
<member name="M:Prime.List.areSameLength``2(Microsoft.FSharp.Collections.FSharpList{``0},Microsoft.FSharp.Collections.FSharpList{``1})">
<summary>
 Check that two lists are of the same length.
</summary>
</member>
<member name="M:Prime.List.hasBetween``1(System.Int32,System.Int32,Microsoft.FSharp.Collections.FSharpList{``0})">
<summary>
 Check that a list has at least n items.
</summary>
</member>
<member name="M:Prime.List.hasExactly``1(System.Int32,Microsoft.FSharp.Collections.FSharpList{``0})">
<summary>
 Check that a list has exactly n items.
</summary>
</member>
<member name="M:Prime.List.hasAtMost``1(System.Int32,Microsoft.FSharp.Collections.FSharpList{``0})">
<summary>
 Check that a list has at most n items.
</summary>
</member>
<member name="M:Prime.List.hasAtLeast``1(System.Int32,Microsoft.FSharp.Collections.FSharpList{``0})">
<summary>
 Check that a list has at least n items.
</summary>
</member>
<member name="M:Prime.List.partitionPlus``2(Microsoft.FSharp.Core.FSharpFunc{``0,Microsoft.FSharp.Core.FSharpOption{``1}},Microsoft.FSharp.Collections.FSharpList{``0})">
<summary>
 Partition a list.
</summary>
</member>
<member name="M:Prime.List.flipCons``1(Microsoft.FSharp.Collections.FSharpList{``0},``0)">
<summary>
 Cons with flipped arguments.
</summary>
</member>
<member name="M:Prime.List.cons``1(``0,Microsoft.FSharp.Collections.FSharpList{``0})">
<summary>
 The missing cons function.
</summary>
</member>
<member name="M:Prime.List.singleton``1(``0)">
<summary>
 Make a singleton list.
</summary>
</member>
<member name="M:Prime.List.notEmpty``1(Microsoft.FSharp.Collections.FSharpList{``0})">
<summary>
 Check that a list is not empty.
</summary>
</member>
<member name="M:Prime.Set.addMany``1(System.Collections.Generic.IEnumerable{``0},Microsoft.FSharp.Collections.FSharpSet{``0})">
<summary>
 Add multiple values to a set.
</summary>
</member>
<member name="M:Prime.Set.singleton``1(``0)">
<summary>
 Make a singleton set.
</summary>
</member>
<member name="M:Prime.Set.notEmpty``1(Microsoft.FSharp.Collections.FSharpSet{``0})">
<summary>
 Check that a set is not empty.
</summary>
</member>
<member name="M:Prime.MapOperators.op_AtAt``2(Microsoft.FSharp.Collections.FSharpMap{``0,``1},System.Collections.Generic.IEnumerable{System.Collections.Generic.KeyValuePair{``0,``1}})">
<summary>
 Combine the contents of two maps, taking an item from the second map in case of a key overlap.
</summary>
</member>
<member name="M:Prime.Map.concat``2(Microsoft.FSharp.Collections.FSharpMap{``0,``1},System.Collections.Generic.IEnumerable{System.Collections.Generic.KeyValuePair{``0,``1}})">
<summary>
 Combine the contents of two maps, taking an item from the second map in the case of a key
 conflict.
</summary>
</member>
<member name="M:Prime.Map.toValueListBy``3(Microsoft.FSharp.Core.FSharpFunc{``0,``1},Microsoft.FSharp.Collections.FSharpMap{``2,``0})">
<summary>
 Convert a list of a map&apos;s values by a function.
</summary>
</member>
<member name="M:Prime.Map.toValueList``2(Microsoft.FSharp.Collections.FSharpMap{``0,``1})">
<summary>
 Get a list of a map&apos;s values.
</summary>
</member>
<member name="M:Prime.Map.toKeyListBy``4(Microsoft.FSharp.Core.FSharpFunc{``0,Microsoft.FSharp.Core.FSharpFunc{``1,``2}},Microsoft.FSharp.Collections.FSharpMap{System.Tuple{``0,``3},``1})">
<summary>
 Convert a list of a map&apos;s keys by a function.
</summary>
</member>
<member name="M:Prime.Map.toKeyList``2(Microsoft.FSharp.Collections.FSharpMap{``0,``1})">
<summary>
 Get a list of a map&apos;s keys.
</summary>
</member>
<member name="M:Prime.Map.toListBy``3(Microsoft.FSharp.Core.FSharpFunc{``0,Microsoft.FSharp.Core.FSharpFunc{``1,``2}},Microsoft.FSharp.Collections.FSharpMap{``0,``1})">
<summary>
 Convert a map to a list by a function.
</summary>
</member>
<member name="M:Prime.Map.ofListBy``3(Microsoft.FSharp.Core.FSharpFunc{``0,System.Tuple{``1,``2}},Microsoft.FSharp.Collections.FSharpList{``0})">
<summary>
 Make a map from a list by a function.
</summary>
</member>
<member name="M:Prime.Map.toValueSeqBy``3(Microsoft.FSharp.Core.FSharpFunc{``0,``1},Microsoft.FSharp.Collections.FSharpMap{``2,``0})">
<summary>
 Convert a seq of a map&apos;s values by a function.
</summary>
</member>
<member name="M:Prime.Map.toValueSeq``2(Microsoft.FSharp.Collections.FSharpMap{``0,``1})">
<summary>
 Get a seq of a map&apos;s values.
</summary>
</member>
<member name="M:Prime.Map.toKeySeqBy``3(Microsoft.FSharp.Core.FSharpFunc{``0,``1},Microsoft.FSharp.Collections.FSharpMap{``0,``2})">
<summary>
 Convert a seq of a map&apos;s keys by a function.
</summary>
</member>
<member name="M:Prime.Map.toKeySeq``2(Microsoft.FSharp.Collections.FSharpMap{``0,``1})">
<summary>
 Get a seq of a map&apos;s keys.
</summary>
</member>
<member name="M:Prime.Map.toSeqBy``3(Microsoft.FSharp.Core.FSharpFunc{``0,Microsoft.FSharp.Core.FSharpFunc{``1,``2}},Microsoft.FSharp.Collections.FSharpMap{``0,``1})">
<summary>
 Convert a map to a seq by a function.
</summary>
</member>
<member name="M:Prime.Map.ofSeqBy``3(Microsoft.FSharp.Core.FSharpFunc{``0,System.Tuple{``1,``2}},System.Collections.Generic.IEnumerable{``0})">
<summary>
 Make a map from a seq by a function.
</summary>
</member>
<member name="M:Prime.Map.addMany``2(System.Collections.Generic.IEnumerable{System.Tuple{``0,``1}},Microsoft.FSharp.Collections.FSharpMap{``0,``1})">
<summary>
 Add multiple values to a map.
</summary>
</member>
<member name="M:Prime.Map.singleton``2(``0,``1)">
<summary>
 Make a singleton map.
</summary>
</member>
<member name="M:Prime.Map.notEmpty``2(Microsoft.FSharp.Collections.FSharpMap{``0,``1})">
<summary>
 Check that a map is not empty.
</summary>
</member>
<member name="M:Prime.HashSetOperators.hashSetPlus``1(System.Collections.Generic.IEnumerable{``0})">
<summary>
 Make a concrete HashSet instance populated with the given items and using structural hashing.
</summary>
</member>
<member name="M:Prime.HashSetOperators.hashSet``1(System.Collections.Generic.IEnumerable{``0})">
<summary>
 Make a concrete HashSet instance populated with the given items and using vanilla hashing.
</summary>
</member>
<member name="M:Prime.HashSetExtension.HashSet`1.TryAdd``1(System.Collections.Generic.HashSet{``0},``0)">
<summary>
 Try to add an item, returning false upon failure.
</summary>
</member>
<member name="M:Prime.HashSet.singleton``1(``0)">
<summary>
 Make a hash set with a single item.
</summary>
</member>
<member name="M:Prime.DictionaryOperators.dictPlus``2(System.Collections.Generic.IEnumerable{System.Tuple{``0,``1}})">
<summary>
 Like dict, but returns a concrete Dictionary instance with structural hashing.
 NOTE: Also uses forced adding, allowing multiple of the same key in the kvps.
</summary>
</member>
<member name="M:Prime.DictionaryExtension.Dictionary`2.ValueEquals``2(System.Collections.Generic.Dictionary{``0,``1},System.Collections.Generic.Dictionary{``0,``1})">
<summary>
 Check value equality of dictionary.
 NOTE: be wary the highly imperative nature of this code.
</summary>
</member>
<member name="M:Prime.DictionaryExtension.Dictionary`2.TryAdd``2(System.Collections.Generic.Dictionary{``0,``1},``0,``1)">
<summary>
 Try to add an entry, returning false upon failure.
</summary>
</member>
<member name="M:Prime.DictionaryExtension.Dictionary`2.ForceAdd``2(System.Collections.Generic.Dictionary{``0,``1},``0,``1)">
<summary>
 Force the addition of an entry, replacing the existing one if necessary.
</summary>
</member>
<member name="M:Prime.Dictionary.tryFind``2(``0,System.Collections.Generic.Dictionary{``0,``1})">
<summary>
 Try to find a value in a dictonary.
</summary>
</member>
<member name="M:Prime.Dictionary.map``2(Microsoft.FSharp.Core.FSharpFunc{System.Collections.Generic.KeyValuePair{``0,``1},``1},System.Collections.Generic.Dictionary{``0,``1})">
<summary>
 Map over a dictionary. A new dictionary is produced.
</summary>
</member>
<member name="M:Prime.Dictionary.singleton``2(``0,``1)">
<summary>
 Make a dictionary with a single entry.
</summary>
</member>
<member name="T:Prime.RandModule.Rand">
<summary>
 An immutable random number generator using the xorshift* algorithm.
</summary>
</member>
<member name="M:Prime.RandModule.RandModule.make">
<summary>
 Make a rand value generator from the default seed state.
</summary>
</member>
<member name="M:Prime.RandModule.RandModule.makeFromInt(System.Int32)">
<summary>
 Make a rand value generator from the given int seed state.
 May not be zero.
</summary>
</member>
<member name="M:Prime.RandModule.RandModule.makeFromSeedState(System.UInt64)">
<summary>
 Make a rand value generator from the given seed state.
 May not be zero.
</summary>
</member>
<member name="M:Prime.RandModule.RandModule.nextInt64Under(System.UInt64,Prime.RandModule.Rand)">
<summary>
 Get the next random value below the given maximum as an int64 type.
</summary>
</member>
<member name="M:Prime.RandModule.RandModule.nextInt64(Prime.RandModule.Rand)">
<summary>
 Get the next random value as an int64 type.
 NOTE: System.Random.Next will never return Int64.MaxValue, but this will.
</summary>
</member>
<member name="M:Prime.RandModule.RandModule.nextIntUnder(System.Int32,Prime.RandModule.Rand)">
<summary>
 Get the next random value below the given maximum as an int type.
</summary>
</member>
<member name="M:Prime.RandModule.RandModule.nextInt(Prime.RandModule.Rand)">
<summary>
 Get the next random value as an int type.
 NOTE: System.Random.Next will never return Int32.MaxValue, but this will.
</summary>
</member>
<member name="M:Prime.RandModule.RandModule.nextSingleUnder(System.Single,Prime.RandModule.Rand)">
<summary>
 Get the next random value below the given maximum as a single type.
</summary>
</member>
<member name="M:Prime.RandModule.RandModule.nextSingle(Prime.RandModule.Rand)">
<summary>
 Get the next random value as a double type.
</summary>
</member>
<member name="M:Prime.RandModule.RandModule.nextDoubleUnder(System.Double,Prime.RandModule.Rand)">
<summary>
 Get the next random value below the given maximum as a double type.
</summary>
</member>
<member name="M:Prime.RandModule.RandModule.nextDouble(Prime.RandModule.Rand)">
<summary>
 Get the next random value as a double type.
</summary>
</member>
<member name="M:Prime.RandModule.RandModule.getState(Prime.RandModule.Rand)">
<summary>
 The internal state of rand, useful for serialization and duplication.
</summary>
</member>
<member name="M:Prime.RandModule.RandModule.advance(Prime.RandModule.Rand)">
<summary>
 Advance the state of rand, thus yielding a new outcome.
</summary>
</member>
<member name="P:Prime.RandModule.RandModule.DefaultSeedState">
<summary>
 The default seed state for rand.
 NOTE: number generated via http://www.random.org/bytes/
</summary>
</member>
<member name="M:Prime.RandModule.RandModule.sample(Prime.RandModule.Rand)">
<summary>
 Get the sample value used to generate the current random value.
</summary>
</member>
<member name="M:Prime.SymbolModule.tryGetOrigin(Prime.Symbol)">
<summary>
 Try to get the Origin of the symbol if it has one.
</summary>
</member>
<member name="M:Prime.SymbolModule.toString(Prime.Symbol)">
<summary>
 Convert a symbol to a string, with the following unparses:
 
 (* Atom values *)
 None
 CharacterAnimationFacing
 
 (* Number values *)
 0.0f
 -5

 (* String value *)
 &quot;String with quoted spaces.&quot;

 (* Quoted value *)
 `[Some 1]
 
 (* Symbols values *)
 []
 [Some 0]
 [Left 0]
 [[0 1] [2 4]]
 [AnimationData 4 8]
 [Gem `[Some 1]]

 ...and so on.
</summary>
</member>
<member name="M:Prime.SymbolModule.fromString(System.String)">
<summary>
 Convert a string to a symbol, with the following parses:
 
 (* Atom values *)
 None
 CharacterAnimationFacing
 
 (* Number values *)
 0.0f
 -5

 (* String value *)
 &quot;String with quoted spaces.&quot;

 (* Quoted value *)
 `[Some 1]
 
 (* Symbols values *)
 []
 [Some 0]
 [Left 0]
 [[0 1] [2 4]]
 [AnimationData 4 8]
 [Gem `[Some 1]]

 ...and so on.
</summary>
</member>
<member name="M:Prime.AddressOperators.acatsf``2(Prime.AddressModule.Address{``0},Prime.AddressModule.Address{``1})">
<summary>
 Concatenate two addresses, forcing the type of second address.
</summary>
</member>
<member name="M:Prime.AddressOperators.acats``1(Prime.AddressModule.Address{System.Object},Prime.AddressModule.Address{``0})">
<summary>
 Concatenate two addresses, taking the type of the second address.
</summary>
</member>
<member name="M:Prime.AddressOperators.acatff``2(Prime.AddressModule.Address{``0},Prime.AddressModule.Address{``1})">
<summary>
 Concatenate two addresses, forcing the type of first address.
</summary>
</member>
<member name="M:Prime.AddressOperators.acatf``1(Prime.AddressModule.Address{``0},Prime.AddressModule.Address{System.Object})">
<summary>
 Concatenate two addresses, taking the type of first address.
</summary>
</member>
<member name="M:Prime.AddressOperators.acat``1(Prime.AddressModule.Address{``0},Prime.AddressModule.Address{``0})">
<summary>
 Concatenate two addresses of the same type.
</summary>
</member>
<member name="M:Prime.AddressOperators.atooa``1(Prime.AddressModule.Address{``0})">
<summary>
 Convert any address to an obj Address.
</summary>
</member>
<member name="M:Prime.AddressOperators.atos``1(Prime.AddressModule.Address{``0})">
<summary>
 Convert an address into a string.
</summary>
</member>
<member name="M:Prime.AddressOperators.ntoa``1(System.String)">
<summary>
 Convert a single name into an address.
</summary>
</member>
<member name="M:Prime.AddressOperators.ltoa``1(Microsoft.FSharp.Collections.FSharpList{System.String})">
<summary>
 Convert a names list into an address.
</summary>
</member>
<member name="M:Prime.AddressOperators.stoa``1(System.String)">
<summary>
 Convert a string into an address.
</summary>
</member>
<member name="M:Prime.AddressOperators.atoa``2(Prime.AddressModule.Address{``0})">
<summary>
 Convert an address of type &apos;a to an address of type &apos;b.
</summary>
</member>
<member name="M:Prime.AddressModule.Address`1.stoa``1(System.String)">
<summary>
 Convert a string into an address.
</summary>
</member>
<member name="M:Prime.AddressModule.Address`1.op_MinusLessMinus``1(Prime.AddressModule.Address{System.Object},Prime.AddressModule.Address{``0})">
<summary>
 Concatenate two addresses, taking the type of the second address.
</summary>
</member>
<member name="M:Prime.AddressModule.Address`1.op_MinusLessLessMinus``1(Prime.AddressModule.Address{`0},Prime.AddressModule.Address{``0})">
<summary>
 Concatenate two addresses, forcing the type of second address.
</summary>
</member>
<member name="M:Prime.AddressModule.Address`1.op_MinusGreaterMinus(Prime.AddressModule.Address{`0},Prime.AddressModule.Address{System.Object})">
<summary>
 Concatenate two addresses, taking the type of first address.
</summary>
</member>
<member name="M:Prime.AddressModule.Address`1.op_MinusGreaterGreaterMinus``1(Prime.AddressModule.Address{`0},Prime.AddressModule.Address{``0})">
<summary>
 Concatenate two addresses, forcing the type of first address.
</summary>
</member>
<member name="M:Prime.AddressModule.Address`1.op_MinusBarMinus(Prime.AddressModule.Address{`0},Prime.AddressModule.Address{`0})">
<summary>
 Concatenate two addresses of the same type.
</summary>
</member>
<member name="M:Prime.AddressModule.Address`1.ntoa``1(System.String)">
<summary>
 Convert a single name into an address.
</summary>
</member>
<member name="M:Prime.AddressModule.Address`1.makeFromString``1(System.String)">
<summary>
 Make an address from a &apos;/&apos; delimited string.
 NOTE: do not move this function as the AddressConverter&apos;s reflection code relies on it being exactly here!
</summary>
</member>
<member name="M:Prime.AddressModule.Address`1.ltoa``1(Microsoft.FSharp.Collections.FSharpList{System.String})">
<summary>
 Convert a names list into an address.
</summary>
</member>
<member name="M:Prime.AddressModule.Address`1.hash(Prime.AddressModule.Address{`0})">
<summary>
 Hash an Address.
</summary>
</member>
<member name="M:Prime.AddressModule.Address`1.equals``2(Prime.AddressModule.Address{``0},Prime.AddressModule.Address{``1})">
<summary>
 Equate Addresses.
</summary>
</member>
<member name="M:Prime.AddressModule.Address`1.compare``2(Prime.AddressModule.Address{``0},Prime.AddressModule.Address{``1})">
<summary>
 Compare Addresses.
</summary>
</member>
<member name="M:Prime.AddressModule.Address`1.atos``1(Prime.AddressModule.Address{`0})">
<summary>
 Convert a string into an address.
</summary>
</member>
<member name="M:Prime.AddressModule.Address`1.atooa``1(Prime.AddressModule.Address{`0})">
<summary>
 Convert any address to an obj Address.
</summary>
</member>
<member name="M:Prime.AddressModule.Address`1.atoa``2(Prime.AddressModule.Address{`0})">
<summary>
 Convert an address of type &apos;a to an address of type &apos;b.
</summary>
</member>
<member name="M:Prime.AddressModule.Address`1.acatsf``2(Prime.AddressModule.Address{`0},Prime.AddressModule.Address{``1})">
<summary>
 Concatenate two addresses, forcing the type of second address.
</summary>
</member>
<member name="M:Prime.AddressModule.Address`1.acats``1(Prime.AddressModule.Address{System.Object},Prime.AddressModule.Address{`0})">
<summary>
 Concatenate two addresses, taking the type of the second address.
</summary>
</member>
<member name="M:Prime.AddressModule.Address`1.acatff``2(Prime.AddressModule.Address{`0},Prime.AddressModule.Address{``1})">
<summary>
 Concatenate two addresses, forcing the type of first address.
</summary>
</member>
<member name="M:Prime.AddressModule.Address`1.acatf``1(Prime.AddressModule.Address{`0},Prime.AddressModule.Address{System.Object})">
<summary>
 Concatenate two addresses, taking the type of first address.
</summary>
</member>
<member name="M:Prime.AddressModule.Address`1.acat``1(Prime.AddressModule.Address{`0},Prime.AddressModule.Address{`0})">
<summary>
 Concatenate two addresses of the same type.
</summary>
</member>
<member name="T:Prime.AddressModule.Address`1">
<summary>
 Specifies the address of an identifiable value.
 TODO: P1: have Address constructor throw if multiple wildcards are used.
</summary>
</member>
<member name="M:Prime.AddressModule.Address.notEmpty``1(Prime.AddressModule.Address{``0})">
<summary>
 Check that an address has one or more names.
</summary>
</member>
<member name="M:Prime.AddressModule.Address.isEmpty``1(Prime.AddressModule.Address{``0})">
<summary>
 Check that an address is devoid of names.
</summary>
</member>
<member name="M:Prime.AddressModule.Address.length``1(Prime.AddressModule.Address{``0})">
<summary>
 Get the length of an address by its names.
</summary>
</member>
<member name="M:Prime.AddressModule.Address.allButLast``2(Prime.AddressModule.Address{``0})">
<summary>
 Take an address composed of all but the last name of an address.
</summary>
</member>
<member name="M:Prime.AddressModule.Address.last``1(Prime.AddressModule.Address{``0})">
<summary>
 Take the last name of an address.
</summary>
</member>
<member name="M:Prime.AddressModule.Address.tryTake``2(System.Int32,Prime.AddressModule.Address{``0})">
<summary>
 Take an address composed of the given number of names of an address.
</summary>
</member>
<member name="M:Prime.AddressModule.Address.take``2(System.Int32,Prime.AddressModule.Address{``0})">
<summary>
 Take an address composed of the given number of names of an address.
</summary>
</member>
<member name="M:Prime.AddressModule.Address.skip``2(System.Int32,Prime.AddressModule.Address{``0})">
<summary>
 Take an address composed of the name of an address minus a skipped amount of names.
</summary>
</member>
<member name="M:Prime.AddressModule.Address.item``1(System.Int32,Prime.AddressModule.Address{``0})">
<summary>
 Take a name of an address.
</summary>
</member>
<member name="M:Prime.AddressModule.Address.tail``2(Prime.AddressModule.Address{``0})">
<summary>
 Take the tail of an address.
</summary>
</member>
<member name="M:Prime.AddressModule.Address.head``1(Prime.AddressModule.Address{``0})">
<summary>
 Take the head of an address.
</summary>
</member>
<member name="M:Prime.AddressModule.Address.getHashCode``1(Prime.AddressModule.Address{``0})">
<summary>
 Get the address&apos;s hash code.
</summary>
</member>
<member name="M:Prime.AddressModule.Address.getName``1(Prime.AddressModule.Address{``0})">
<summary>
 Get the name of an address.
</summary>
</member>
<member name="M:Prime.AddressModule.Address.changeType``2(Prime.AddressModule.Address{``0})">
<summary>
 Change the type of an address.
</summary>
</member>
<member name="M:Prime.AddressModule.Address.getNames``1(Prime.AddressModule.Address{``0})">
<summary>
 Get the names of an address.
</summary>
</member>
<member name="M:Prime.AddressModule.Address.makeFromName``1(System.String)">
<summary>
 Make an address from a name.
</summary>
</member>
<member name="M:Prime.AddressModule.Address.makeFromList``1(Microsoft.FSharp.Collections.FSharpList{System.String})">
<summary>
 Make an address from a list of names.
</summary>
</member>
<member name="M:Prime.AddressModule.Address.empty``1">
<summary>
 The empty address.
</summary>
</member>
<member name="M:Prime.RelationModule.Relation`1.unresolve``2(Prime.AddressModule.Address{`0},Prime.AddressModule.Address{``1})">
<summary>
 Unresolve an address to the most general form in the context of another address.
</summary>
</member>
<member name="M:Prime.RelationModule.Relation`1.resolve``2(Prime.AddressModule.Address{`0},Prime.RelationModule.Relation{``1})">
<summary>
 Resolve a relationship to an address.
</summary>
</member>
<member name="M:Prime.RelationModule.Relation`1.makeFromString``1(System.String)">
<summary>
 Make a relation from a &apos;/&apos; delimited string where &apos;?&apos; names are empty.
 NOTE: do not move this function as the RelationConverter&apos;s reflection code relies on it being exactly here!
</summary>
</member>
<member name="M:Prime.RelationModule.Relation`1.makeFromList``1(Microsoft.FSharp.Collections.FSharpList{System.String})">
<summary>
 Make a relation from a list of names where &quot;?&quot; names are empty.
</summary>
</member>
<member name="M:Prime.RelationModule.Relation`1.makeFromAddress``1(Prime.AddressModule.Address{`0})">
<summary>
 Make a relation from an address where &quot;?&quot; names are empty.
</summary>
</member>
<member name="M:Prime.RelationModule.Relation`1.hash(Prime.RelationModule.Relation{`0})">
<summary>
 Hash a Relation.
</summary>
</member>
<member name="M:Prime.RelationModule.Relation`1.equals``2(Prime.RelationModule.Relation{``0},Prime.RelationModule.Relation{``1})">
<summary>
 Equate Relations.
</summary>
</member>
<member name="T:Prime.RelationModule.Relation`1">
<summary>
 A relation that can be resolved to an address via contextual resolution.
</summary>
</member>
<member name="M:Prime.RelationModule.Relation.changeType``2(Prime.RelationModule.Relation{``0})">
<summary>
 Change the type of an address.
</summary>
</member>
<member name="M:Prime.RelationModule.Relation.getNameOpts``1(Prime.RelationModule.Relation{``0})">
<summary>
 Get the optional names of a relation.
</summary>
</member>
<member name="M:Prime.RelationModule.Relation.makeFromString``1(System.String)">
<summary>
 Make a relation from a &apos;/&apos; delimited string.
</summary>
</member>
<member name="M:Prime.RelationModule.Relation.makeFromList``1(Microsoft.FSharp.Collections.FSharpList{Microsoft.FSharp.Core.FSharpOption{System.String}})">
<summary>
 Make a relation from a list of option names.
</summary>
</member>
<member name="T:Prime.KeyedCacheModule.KeyedCache`2">
<summary>
 Presents a purely-functional interface to a cached value.
 Works by associating a cached value with a given cache key such that the cached value remains valid when queried
 for using the same cache key (as decided by a simple key comparer function), automatically rebuilding the cached
 value and key (as done with a simple factory function).
</summary>
</member>
<member name="M:Prime.KeyedCacheModule.KeyedCache.make``2(``0,``1)">
 <summary>Make a keyed cache value.</summary>
 <param name="cacheKey">The current key against which to validate the cache.</param>
 <param name="cacheValue">The value associated with the cache key.</param>
</member>
<member name="M:Prime.KeyedCacheModule.KeyedCache.getValueFast``2(Microsoft.FSharp.Core.OptimizedClosures.FSharpFunc{``0,``0,System.Boolean},Microsoft.FSharp.Core.FSharpFunc{Microsoft.FSharp.Core.Unit,System.Collections.Generic.KeyValuePair{``0,``1}},``0,Prime.KeyedCacheModule.KeyedCache{``0,``1})">
 <summary>Get the cached value without allocating if possible.</summary>
 <param name="keyEquality">Determines the equality of the key used to consider if the cache is valid.</param>
 <param name="getFreshKeyAndValue">Generates a fresh key and corresponding value to cache.</param>
 <param name="cacheKey">The current key against which to validate the cache.</param>
 <param name="keyedCache">The keyed cache.</param>
</member>
<member name="M:Prime.KeyedCacheModule.KeyedCache.getValue``2(Microsoft.FSharp.Core.FSharpFunc{``0,Microsoft.FSharp.Core.FSharpFunc{``0,System.Boolean}},Microsoft.FSharp.Core.FSharpFunc{Microsoft.FSharp.Core.Unit,System.Collections.Generic.KeyValuePair{``0,``1}},``0,Prime.KeyedCacheModule.KeyedCache{``0,``1})">
 <summary>Get the cached value.</summary>
 <param name="keyEquality">Determines the equality of the key used to consider if the cache is valid.</param>
 <param name="getFreshKeyAndValue">Generates a fresh key and corresponding value to cache.</param>
 <param name="cacheKey">The current key against which to validate the cache.</param>
 <param name="keyedCache">The keyed cache.</param>
</member>
<member name="T:Prime.MutantCacheModule.MutantCache`1">
<summary>
 Presents a purely-functional interface to a mutable object / record / whatever.
 If it is not satisfactorily efficient to run a clone operation on the mutant for every get,
 just pass in the id function for make&apos;s cloneMutant arg, but make sure to NEVER mutate the
 returned mutant!
</summary>
</member>
<member name="M:Prime.MutantCacheModule.MutantCache.make``1(Microsoft.FSharp.Core.FSharpFunc{``0,``0},``0)">
 <summary>Make a mutant cache.</summary>
 <param name="cloneMutant">
 A function to clone the mutant before presenting it to the outside world.
 Feel free to pass id if you can ensure that the presented mutant will never be mutated externally.
 </param>
 <param name="mutant">The mutant (mutable object / record / whatever) to be cached.</param>
</member>
<member name="M:Prime.MutantCacheModule.MutantCache.mutateMutant``1(Microsoft.FSharp.Core.FSharpFunc{Microsoft.FSharp.Core.Unit,``0},Microsoft.FSharp.Core.FSharpFunc{``0,``0},Prime.MutantCacheModule.MutantCache{``0})">
 <summary>Mutate the underlying mutant (mutable object / record / whatever).</summary>
 <param name="rebuildMutant">A function that rebuilds the mutant from scratch in case the current underlying mutant is out of date.</param>
 <param name="mutateMutant">A function that mutates the underlying mutant.</param>
 <param name="mutantCache">The mutant cache.</param>
</member>
<member name="M:Prime.MutantCacheModule.MutantCache.getMutant``1(Microsoft.FSharp.Core.FSharpFunc{Microsoft.FSharp.Core.Unit,``0},Prime.MutantCacheModule.MutantCache{``0})">
 <summary>Get the underlying mutant (mutable object / record / whatever).</summary>
 <param name="rebuildMutant">A function that rebuilds the mutant from scratch in case the current underlying mutant is out of date.</param>
 <param name="mutantCache">The mutant cache.</param>
</member>
<member name="M:Prime.TListModule.TList.removeMany``1(System.Collections.Generic.IEnumerable{``0},Prime.TListModule.TList{``0})">
<summary>
 Remove all the given values from the list.
</summary>
</member>
<member name="M:Prime.TListModule.TList.addMany``1(System.Collections.Generic.IEnumerable{``0},Prime.TListModule.TList{``0})">
<summary>
 Add all the given values to the list.
</summary>
</member>
<member name="M:Prime.TListModule.TList.toSeq``1(Prime.TListModule.TList{``0})">
<summary>
 Convert a TList to a seq. Note that entire list is iterated eagerly since the underlying .NET List could
 otherwise opaquely change during iteration.
</summary>
</member>
<member name="M:Prime.TListModule.TList.toArray``1(Prime.TListModule.TList{``0})">
<summary>
 Convert a TList to an array. Note that entire list is iterated eagerly since the underlying .NET List could
 otherwise opaquely change during iteration.
</summary>
</member>
<member name="M:Prime.TListModule.TList.contains``1(``0,Prime.TListModule.TList{``0})">
<summary>
 Check that a value is contain in the list.
</summary>
</member>
<member name="M:Prime.TListModule.TList.length``1(Prime.TListModule.TList{``0})">
<summary>
 Get the length of the list (constant-time, obviously).
</summary>
</member>
<member name="M:Prime.TMapModule.TMap.toSeq``2(Prime.TMapModule.TMap{``0,``1})">
<summary>
 Convert a TMap to a seq. Note that entire map is iterated eagerly since the underlying
 Dictionary could otherwise opaquely change during iteration.
</summary>
</member>
<member name="M:Prime.TMapModule.TMap.removeMany``2(System.Collections.Generic.IEnumerable{``0},Prime.TMapModule.TMap{``0,``1})">
<summary>
 Remove all values with the given keys from the map.
</summary>
</member>
<member name="M:Prime.TMapModule.TMap.addMany``2(System.Collections.Generic.IEnumerable{System.Tuple{``0,``1}},Prime.TMapModule.TMap{``0,``1})">
<summary>
 Add all the given entries to the map.
</summary>
</member>
<member name="M:Prime.TMapModule.TMap.length``2(Prime.TMapModule.TMap{``0,``1})">
<summary>
 Get the length of the map (constant-time, obviously).
</summary>
</member>
<member name="M:Prime.TSetModule.TSet.toSeq``1(Prime.TSetModule.TSet{``0})">
<summary>
 Convert a TSet to a seq. Note that entire set is iterated eagerly since the underlying HashMap could
 otherwise opaquely change during iteration.
</summary>
</member>
<member name="M:Prime.TSetModule.TSet.removeMany``1(System.Collections.Generic.IEnumerable{``0},Prime.TSetModule.TSet{``0})">
<summary>
 Remove all the given values from the set.
</summary>
</member>
<member name="M:Prime.TSetModule.TSet.addMany``1(System.Collections.Generic.IEnumerable{``0},Prime.TSetModule.TSet{``0})">
<summary>
 Add all the given values to the set.
</summary>
</member>
<member name="M:Prime.TSetModule.TSet.length``1(Prime.TSetModule.TSet{``0})">
<summary>
 Get the length of the set (constant-time, obviously).
</summary>
</member>
<member name="M:Prime.UListModule.UList.removeMany``1(System.Collections.Generic.IEnumerable{``0},Prime.UListModule.UList{``0})">
<summary>
 Remove all the given values from the list.
</summary>
</member>
<member name="M:Prime.UListModule.UList.addMany``1(System.Collections.Generic.IEnumerable{``0},Prime.UListModule.UList{``0})">
<summary>
 Add all the given values to the list.
</summary>
</member>
<member name="M:Prime.UMapModule.UMap.removeMany``2(System.Collections.Generic.IEnumerable{``0},Prime.UMapModule.UMap{``0,``1})">
<summary>
 Remove all values with the given keys from the map.
</summary>
</member>
<member name="M:Prime.UMapModule.UMap.addMany``2(System.Collections.Generic.IEnumerable{System.Tuple{``0,``1}},Prime.UMapModule.UMap{``0,``1})">
<summary>
 Add all the given entries to the map.
</summary>
</member>
<member name="M:Prime.USetModule.USet.removeMany``1(System.Collections.Generic.IEnumerable{``0},Prime.USetModule.USet{``0})">
<summary>
 Remove all the given values from the set.
</summary>
</member>
<member name="M:Prime.USetModule.USet.addMany``1(System.Collections.Generic.IEnumerable{``0},Prime.USetModule.USet{``0})">
<summary>
 Add all the given values to the set.
</summary>
</member>
<member name="T:Prime.HMapModule.HMap`2">
<summary>
 A fast persistent hash map.
 Works in effectively constant-time for look-ups and updates.
</summary>
</member>
<member name="T:Prime.HMapModule.HNode`2">
<summary>
 Hash map node.
</summary>
</member>
<member name="T:Prime.HMapModule.Hkv`2">
<summary>
 A hash-key-value triple, implemented with a struct for efficiency.
</summary>
</member>
<member name="M:Prime.HMapModule.HMap.ofSeq``2(System.Collections.Generic.IEnumerable{System.Tuple{``0,``1}})">
<summary>
 Convert a sequence of keys and values to an HMap.
</summary>
</member>
<member name="M:Prime.HMapModule.HMap.toSeq``2(Prime.HMapModule.HMap{``0,``1})">
<summary>
 Convert an HMap to a sequence of pairs of keys and values.
 NOTE: This function seems to profile as being very slow. I don&apos;t know if it&apos;s the seq / yields syntax or what.
 Don&apos;t use it unless you need its laziness or if performance won&apos;t be affected significantly.
</summary>
</member>
<member name="M:Prime.HMapModule.HMap.filter``2(Microsoft.FSharp.Core.FSharpFunc{``0,Microsoft.FSharp.Core.FSharpFunc{``1,System.Boolean}},Prime.HMapModule.HMap{``0,``1})">
<summary>
 Filter an HMap.
</summary>
</member>
<member name="M:Prime.HMapModule.HMap.map``3(Microsoft.FSharp.Core.FSharpFunc{``0,``1},Prime.HMapModule.HMap{``2,``0})">
<summary>
 Map over an HMap.
</summary>
</member>
<member name="M:Prime.HMapModule.HMap.fold``3(Microsoft.FSharp.Core.FSharpFunc{``0,Microsoft.FSharp.Core.FSharpFunc{``1,Microsoft.FSharp.Core.FSharpFunc{``2,``0}}},``0,Prime.HMapModule.HMap{``1,``2})">
<summary>
 Fold over an HMap.
</summary>
</member>
<member name="M:Prime.HMapModule.HMap.concat``2(Prime.HMapModule.HMap{``0,``1},System.Collections.Generic.IEnumerable{System.Tuple{``0,``1}})">
<summary>
 Combine the contents of two HMaps, taking an item from the second map in the case of a key conflict.
</summary>
</member>
<member name="M:Prime.HMapModule.HMap.containsKey``2(``0,Prime.HMapModule.HMap{``0,``1})">
<summary>
 Check that an HMap contains a value with the given key.
</summary>
</member>
<member name="M:Prime.HMapModule.HMap.find``2(``0,Prime.HMapModule.HMap{``0,``1})">
<summary>
 Find a value with the given key in an HMap.
 Constant-time complexity with approx. 1/3 speed of Dictionary.GetValue.
</summary>
</member>
<member name="M:Prime.HMapModule.HMap.tryFind``2(``0,Prime.HMapModule.HMap{``0,``1})">
<summary>
 Try to find a value with the given key in an HMap.
 Constant-time complexity with approx. 1/3 speed of Dictionary.TryGetValue.
</summary>
</member>
<member name="M:Prime.HMapModule.HMap.tryFindFast``2(``0,Prime.HMapModule.HMap{``0,``1})">
<summary>
 Try to find a value with the given key in an HMap.
 Constant-time complexity with approx. 1/3 speed of Dictionary.TryGetValue.
</summary>
</member>
<member name="M:Prime.HMapModule.HMap.removeMany``2(System.Collections.Generic.IEnumerable{``0},Prime.HMapModule.HMap{``0,``1})">
<summary>
 Remove all values with the given keys from an HMap.
</summary>
</member>
<member name="M:Prime.HMapModule.HMap.addMany``2(System.Collections.Generic.IEnumerable{System.Tuple{``0,``1}},Prime.HMapModule.HMap{``0,``1})">
<summary>
 Add all the given entries to an HMap.
</summary>
</member>
<member name="M:Prime.HMapModule.HMap.remove``2(``0,Prime.HMapModule.HMap{``0,``1})">
<summary>
 Remove a value with the given key from an HMap.
</summary>
</member>
<member name="M:Prime.HMapModule.HMap.add``2(``0,``1,Prime.HMapModule.HMap{``0,``1})">
<summary>
 Add a value with the key to an HMap.
</summary>
</member>
<member name="M:Prime.HMapModule.HMap.notEmpty``2(Prime.HMapModule.HMap{``0,``1})">
<summary>
 Check that an HMap is empty.
</summary>
</member>
<member name="M:Prime.HMapModule.HMap.isEmpty``2(Prime.HMapModule.HMap{``0,``1})">
<summary>
 Check that an HMap is empty.
</summary>
</member>
<member name="M:Prime.HMapModule.HMap.makeEmpty``2">
<summary>
 Create an empty HMap.
</summary>
</member>
<member name="M:Prime.HMapModule.HNode.toSeq``2(Prime.HMapModule.HNode{``0,``1})">
<summary>
 NOTE: This function seems to profile as being very slow. I don&apos;t know if it&apos;s the seq / yields syntax or what.
</summary>
</member>
<member name="M:Prime.HMapModule.HNode.add``2(Prime.HMapModule.Hkv{``0,``1},Prime.HMapModule.HNode{``0,``1}[],System.Int32,Prime.HMapModule.HNode{``0,``1})">
<summary>
 OPTIMIZATION: Requires an empty array to use the source of new array clones in order to avoid Array.create.
</summary>
</member>
<member name="M:Prime.HMapModule.HNode.cloneArray``2(Prime.HMapModule.HNode{``0,``1}[])">
<summary>
 OPTIMIZATION: Array.Clone () is not used since it&apos;s been profiled to be slower
</summary>
</member>
<member name="T:Prime.HSetModule.HSet`1">
<summary>
 A fast persistent hash set.
 Works in effectively constant-time for look-ups and updates.
</summary>
</member>
<member name="T:Prime.HSetModule.HNode`1">
<summary>
 Hash set node.
</summary>
</member>
<member name="T:Prime.HSetModule.Hv`1">
<summary>
 A hash-value pair, implemented with a struct for efficiency.
</summary>
</member>
<member name="M:Prime.HSetModule.HSet.ofSeq``1(System.Collections.Generic.IEnumerable{``0})">
<summary>
 Convert a sequence of keys and values to an HSet.
</summary>
</member>
<member name="M:Prime.HSetModule.HSet.toSeq``1(Prime.HSetModule.HSet{``0})">
<summary>
 Convert an HSet to a sequence of pairs of keys and values.
 NOTE: This function seems to profile as being very slow. I don&apos;t know if it&apos;s the seq / yields syntax or what.
 Don&apos;t use it unless you need its laziness or if performance won&apos;t be affected significantly.
</summary>
</member>
<member name="M:Prime.HSetModule.HSet.filter``1(Microsoft.FSharp.Core.FSharpFunc{``0,System.Boolean},Prime.HSetModule.HSet{``0})">
<summary>
 Filter an HSet.
</summary>
</member>
<member name="M:Prime.HSetModule.HSet.map``2(Microsoft.FSharp.Core.FSharpFunc{``0,``1},Prime.HSetModule.HSet{``0})">
<summary>
 Map over an HSet.
</summary>
</member>
<member name="M:Prime.HSetModule.HSet.fold``2(Microsoft.FSharp.Core.FSharpFunc{``0,Microsoft.FSharp.Core.FSharpFunc{``1,``0}},``0,Prime.HSetModule.HSet{``1})">
<summary>
 Fold over an HSet.
</summary>
</member>
<member name="M:Prime.HSetModule.HSet.concat``1(Prime.HSetModule.HSet{``0},System.Collections.Generic.IEnumerable{``0})">
<summary>
 Combine the contents of two HSets.
</summary>
</member>
<member name="M:Prime.HSetModule.HSet.contains``1(``0,Prime.HSetModule.HSet{``0})">
<summary>
 Check that an HSet contains a value.
</summary>
</member>
<member name="M:Prime.HSetModule.HSet.removeMany``1(System.Collections.Generic.IEnumerable{``0},Prime.HSetModule.HSet{``0})">
<summary>
 Remove all values with the given keys from an HSet.
</summary>
</member>
<member name="M:Prime.HSetModule.HSet.remove``1(``0,Prime.HSetModule.HSet{``0})">
<summary>
 Remove a value with the given key from an HSet.
</summary>
</member>
<member name="M:Prime.HSetModule.HSet.addMany``1(System.Collections.Generic.IEnumerable{``0},Prime.HSetModule.HSet{``0})">
<summary>
 Add a list of values with associated keys to an HSet.
</summary>
</member>
<member name="M:Prime.HSetModule.HSet.add``1(``0,Prime.HSetModule.HSet{``0})">
<summary>
 Add a value with the key to an HSet.
</summary>
</member>
<member name="M:Prime.HSetModule.HSet.notEmpty``1(Prime.HSetModule.HSet{``0})">
<summary>
 Check that an HSet is empty.
</summary>
</member>
<member name="M:Prime.HSetModule.HSet.isEmpty``1(Prime.HSetModule.HSet{``0})">
<summary>
 Check that an HSet is empty.
</summary>
</member>
<member name="M:Prime.HSetModule.HSet.makeEmpty``1">
<summary>
 Create an empty HSet.
</summary>
</member>
<member name="M:Prime.HSetModule.HNode.toSeq``1(Prime.HSetModule.HNode{``0})">
<summary>
 NOTE: This function seems to profile as being very slow. I don&apos;t know if it&apos;s the seq / yields syntax or what.
</summary>
</member>
<member name="M:Prime.HSetModule.HNode.add``1(Prime.HSetModule.Hv{``0},Prime.HSetModule.HNode{``0}[],System.Int32,Prime.HSetModule.HNode{``0})">
<summary>
 OPTIMIZATION: Requires an empty array to use the source of new array clones in order to avoid Array.create.
</summary>
</member>
<member name="M:Prime.HSetModule.HNode.cloneArray``1(Prime.HSetModule.HNode{``0}[])">
<summary>
 OPTIMIZATION: Array.Clone () is not used since it&apos;s been profiled to be slower
</summary>
</member>
<member name="P:Prime.VsyncBuilderModule.vsync">
<summary>
 The VsyncBuilder instance.
 Used like: vsync { return 0 }
</summary>
</member>
<member name="T:Prime.VsyncModule.Vsync`1">
<summary>
 The &apos;Vsync&apos; (AKA, &apos;Variable Synchrony&apos;) monad.
 Allows code to run in either an async or synchronous fashion to aid in debugging.
 NOTE: to reference how all this stuff works in F#, see here - https://msdn.microsoft.com/en-us/library/dd233182.aspx
</summary>
</member>
<member name="M:Prime.VsyncModule.Vsync.Map``2(Microsoft.FSharp.Core.FSharpFunc{``0,``1},Prime.VsyncModule.Vsync{``0})">
<summary>
 Creates a potentially asynchronous operation that runs &apos;f&apos; over computation of &apos;a&apos;.
</summary>
</member>
<member name="M:Prime.VsyncModule.Vsync.Parallel``1(System.Collections.Generic.IEnumerable{Prime.VsyncModule.Vsync{``0}})">
<summary>
 Creates a potentially asynchronous computation that executes all the given computations
 Initially queues each as work item using a fork/join pattern when asynchronous.
 Executes each work item sequentially on the same thread otherwise.
</summary>
</member>
<member name="M:Prime.VsyncModule.Vsync.Catch``1(Prime.VsyncModule.Vsync{``0})">
<summary>
 Creates a potentially asynchronous computation that executes computation.
 If this computation completes successfully, then return Choice1Of2 with the returned value.
 If this computation raises before completion, then return Choice2Of2 with the raised exception.
</summary>
</member>
<member name="M:Prime.VsyncModule.Vsync.AwaitTask(System.Threading.Tasks.Task)">
<summary>
 Return a potentially asynchronous computation that will wait for the given task to complete and return its result.
</summary>
</member>
<member name="M:Prime.VsyncModule.Vsync.AwaitTaskT``1(System.Threading.Tasks.Task{``0})">
<summary>
 Return a potentially asynchronous computation that will wait for the given task to complete and return its result.
</summary>
</member>
<member name="M:Prime.VsyncModule.Vsync.StartAsTask``1(Prime.VsyncModule.Vsync{``0})">
<summary>
 Executes a computation in the thread pool when asynchronous, in the same thread otherwise.
</summary>
</member>
<member name="M:Prime.VsyncModule.Vsync.Start(Prime.VsyncModule.Vsync{Microsoft.FSharp.Core.Unit})">
<summary>
 Starts the potentially asynchronous computation.
 Computation is run in the thread pool not awaiting its result when asynchronous.
 Computation is run in the current thread awaiting its result otherwise.
</summary>
</member>
<member name="M:Prime.VsyncModule.Vsync.RunSynchronously``1(Prime.VsyncModule.Vsync{``0})">
<summary>
 Runs the potentially asynchronous computation and awaits its result.
</summary>
</member>
<member name="M:Prime.VsyncModule.Vsync.Sleep(System.Int32)">
<summary>
 Creates a potentially asynchronous computation that will sleep for the given time.
 The operation will not block operating system threads for the duration of the wait when running asynchronously.
 The operation will block operating system thread for the duration of the wait otherwise.
</summary>
</member>
<member name="M:Prime.VsyncModule.Vsync.Ignore``1(Prime.VsyncModule.Vsync{``0})">
<summary>
 Creates a potentially asynchronous computation that runs the given computation and ignores its results.
</summary>
</member>
<member name="M:Prime.VsyncModule.Vsync.TryFinally``1(Prime.VsyncModule.Vsync{``0},Microsoft.FSharp.Core.FSharpFunc{Microsoft.FSharp.Core.Unit,Microsoft.FSharp.Core.Unit})">
<summary>
 Creates a potentially asynchronous computation that runs computation.
 The action compensation &apos;h&apos; is executed after the computation completes regardless of the outcome.
 If the computation raises and exception itself, the original exception is discarded and the new exception becomes the overall result.
</summary>
</member>
<member name="M:Prime.VsyncModule.Vsync.TryWith``1(Prime.VsyncModule.Vsync{``0},Microsoft.FSharp.Core.FSharpFunc{System.Exception,Prime.VsyncModule.Vsync{``0}})">
<summary>
 Creates a potentially asynchronous computation that runs computation and returns its result.
 If an exception happens, then handler &apos;h&apos; is called and the resulting computation executes instead.
</summary>
</member>
<member name="M:Prime.VsyncModule.Vsync.While(Microsoft.FSharp.Core.FSharpFunc{Microsoft.FSharp.Core.Unit,System.Boolean},Prime.VsyncModule.Vsync{Microsoft.FSharp.Core.Unit})">
<summary>
 Creates a potentially asynchronous computation that runs computation until guard &apos;g&apos; becomes false.
</summary>
</member>
<member name="M:Prime.VsyncModule.Vsync.For``1(System.Collections.Generic.IEnumerable{``0},Microsoft.FSharp.Core.FSharpFunc{``0,Prime.VsyncModule.Vsync{Microsoft.FSharp.Core.Unit}})">
<summary>
 Creates a potentially asynchronous computation that enumerates the sequence &apos;s&apos;, and runs the body &apos;f&apos; for each item.
</summary>
</member>
<member name="M:Prime.VsyncModule.Vsync.Combine``1(Prime.VsyncModule.Vsync{Microsoft.FSharp.Core.Unit},Prime.VsyncModule.Vsync{``0})">
<summary>
 Creates a potentially asynchronous computation that first runs computation &apos;a&apos; and then computation &apos;b&apos;, returning the result of the latter.
</summary>
</member>
<member name="M:Prime.VsyncModule.Vsync.Zero">
<summary>
 Creates a potentially asynchronous computation that just returns unit.
</summary>
</member>
<member name="M:Prime.VsyncModule.Vsync.Delay``1(Microsoft.FSharp.Core.FSharpFunc{Microsoft.FSharp.Core.Unit,Prime.VsyncModule.Vsync{``0}})">
<summary>
 Creates a potentially asynchronous computation that runs generator &apos;f&apos;.
</summary>
</member>
<member name="M:Prime.VsyncModule.Vsync.Using``2(``0,Microsoft.FSharp.Core.FSharpFunc{``0,Prime.VsyncModule.Vsync{``1}})">
<summary>
 Creates a potentially asynchronous computation that runs binder &apos;f&apos; over resource &apos;d&apos;.
 Dispose is executed as this computation yields its result or if the asynchronous computation raises or by cancellation.
</summary>
</member>
<member name="M:Prime.VsyncModule.Vsync.ReturnFrom``1(Prime.VsyncModule.Vsync{``0})">
<summary>
 Delegates to input computation.
</summary>
</member>
<member name="M:Prime.VsyncModule.Vsync.Return``1(``0)">
<summary>
 Creates a potentially asynchronous operation that returns the result &apos;a&apos;.
</summary>
</member>
<member name="M:Prime.VsyncModule.Vsync.Bind``2(Prime.VsyncModule.Vsync{``0},Microsoft.FSharp.Core.FSharpFunc{``0,Prime.VsyncModule.Vsync{``1}})">
<summary>
 Creates a potentially asynchronous operation that runs computation, and when computation results, runs binder resolution.
</summary>
</member>
<member name="M:Prime.VsyncModule.Vsync.isSync">
<summary>
 Query whether Vsync is using synchronized or asynchronous processing.
</summary>
</member>
<member name="M:Prime.VsyncModule.Vsync.init(System.Boolean)">
<summary>
 Initialize Vsync to use synchronized or asynchronous processing.
</summary>
</member>
<member name="P:Prime.VsyncModule.Vsync.SyncOpt">
<summary>
 Configures whether to use synchronized processing.
</summary>
</member>
<member name="M:Prime.Async.Map``2(Microsoft.FSharp.Core.FSharpFunc{``0,``1},Microsoft.FSharp.Control.FSharpAsync{``0})">
<summary>
 Creates an asynchronous operation that runs &apos;f&apos; over computation of &apos;a&apos;.
</summary>
</member>
<member name="T:Prime.Async">
<summary>
 Async extensions.
</summary>
</member>
<member name="M:Prime.TypeExtension.Type.GetGenericName(System.Type)">
<summary>
 Get the generic name of the type, EG - Option&lt;String&gt;
</summary>
</member>
<member name="M:Prime.TypeExtension.Type.GetPropertiesPreferWritable(System.Type)">
<summary>
 Get all the properties, preferring those that can be written to if there is a name clash.
</summary>
</member>
<member name="M:Prime.TypeExtension.Type.GetPropertiesByPreference(System.Type,Microsoft.FSharp.Core.FSharpFunc{System.Reflection.PropertyInfo,System.Boolean})">
<summary>
 Get all the properties that are signalled to be preferred by the &apos;preference&apos; predicate.
</summary>
</member>
<member name="M:Prime.TypeExtension.Type.GetPropertyPreferWritable(System.Type,System.Reflection.BindingFlags)">
<summary>
 Get the property with the given name, preferring the variant that can be written to, or null if none found.
</summary>
</member>
<member name="M:Prime.TypeExtension.Type.GetPropertyByPreference(System.Type,Microsoft.FSharp.Core.FSharpFunc{System.Reflection.PropertyInfo,System.Boolean},System.Reflection.BindingFlags)">
<summary>
 Get the first property with the given name that is signalled to be preferred by the &apos;preference&apos; predicate.
</summary>
</member>
<member name="M:Prime.TypeExtension.Type.GetPropertiesWritable(System.Type,System.String)">
<summary>
 Get all the properties with the give name that can be written to.
</summary>
</member>
<member name="M:Prime.TypeExtension.Type.GetPropertiesWritable(System.Type)">
<summary>
 Get all the properties that can be written to.
</summary>
</member>
<member name="M:Prime.TypeExtension.Type.GetProperties(System.Type,System.String)">
<summary>
 Get all the properties with the given name.
</summary>
</member>
<member name="M:Prime.TypeExtension.Type.GetPropertyWritable(System.Type,System.String)">
<summary>
 Get a property with the given name that can be written to, or null.
</summary>
</member>
<member name="M:Prime.TypeExtension.Type.TryGetCustomTypeConverter(System.Type)">
<summary>
 Try to get a custom type converter for the given type.
</summary>
</member>
<member name="M:Prime.TypeExtension.Type.GetTypeDescriptor(System.Type)">
<summary>
 Get the type descriptor for this type as returned by the global TypeDescriptor.
</summary>
</member>
<member name="M:Prime.TypeExtension.Type.GetDefaultValue(System.Type)">
<summary>
 Get the default value for a type.
 Never returns null.
</summary>
</member>
<member name="M:Prime.TypeExtension.Type.TryGetDefaultValue(System.Type)">
<summary>
 Attempt to get the default value for a type.
 Never returns null.
</summary>
</member>
<member name="M:Prime.Type.GetPropertyByPreference``1(Microsoft.FSharp.Core.FSharpFunc{``0,System.Boolean},``0[])">
<summary>
 Get the first property that is signalled to be preferred by the &apos;preference&apos; predicate.
</summary>
</member>
<member name="M:Prime.Type.GetTypeUnqualified(System.String)">
<summary>
 Get an existing type with the given unqualified name. Time-intensive.
</summary>
</member>
<member name="M:Prime.Type.TryGetTypeUnqualified(System.String)">
<summary>
 Try to get an existing type with the given unqualified name. Time-intensive.
</summary>
</member>
<member name="P:Prime.ReflectionModule.Property">
<summary>
 In tandem with the PropertyDescriptor type, grants a nice syntax to denote properties.
</summary>
</member>
<member name="P:Prime.ReflectionModule.Variable">
<summary>
 In tandem with the VariableDefinition type, grants a nice syntax to define variable properties.
</summary>
</member>
<member name="P:Prime.ReflectionModule.Define">
<summary>
 In tandem with the ValueDefinition type, grants a nice syntax to define value properties.
</summary>
</member>
<member name="M:Prime.SymbolicOperators.scdefaultof``1">
<summary>
 Get the default value of type &apos;a taking into account DefaultValue decorations.
</summary>
</member>
<member name="M:Prime.SymbolicOperators.scvalue``1(System.String)">
<summary>
 Uses a symbolic converter to convert a string to a value.
</summary>
</member>
<member name="M:Prime.SymbolicOperators.scstring``1(``0)">
<summary>
 Uses a symbolic converter to convert a value to a string.
</summary>
</member>
<member name="M:Prime.SymbolicOperators.symbolToValue``1(Prime.Symbol)">
<summary>
 Convert a symbol to a value.
</summary>
</member>
<member name="M:Prime.SymbolicOperators.valueToSymbol``1(``0)">
<summary>
 Convert a value to a symbol.
</summary>
</member>
<member name="T:Prime.MoldModule.Mold">
<summary>
 Describes an F# type in a normalized fashion.
</summary>
</member>
<member name="T:Prime.MoldModule.Primitive">
<summary>
 A primitive mold type.
</summary>
</member>
<member name="T:Prime.MoldModule.InstantiationRules">
<summary>
 Describes the means through which member are instantiated.
</summary>
</member>
<member name="T:Prime.MoldModule.InstantiationRule">
<summary>
 Describes the means through which a member is instantiated.
</summary>
</member>
<member name="T:Prime.MoldModule.MemberPath">
<summary>
 Uniquely identifies a type member.
</summary>
</member>
<member name="T:Prime.MolderModule.Molder">
<summary>
 Automatically converts F# types, molds, and instances as specified by user-defined rules.
</summary>
</member>
<member name="T:Prime.UserStateModule.UserState">
<summary>
 User-defined state.
</summary>
</member>
<member name="M:Prime.UserStateModule.UserStateModule.make``1(``0,System.Boolean)">
<summary>
 Make UserState.
</summary>
</member>
<member name="M:Prime.UserStateModule.UserStateModule.set``1(``0,Prime.UserStateModule.UserState)">
<summary>
 Set the state.
</summary>
</member>
<member name="M:Prime.UserStateModule.UserStateModule.get``1(Prime.UserStateModule.UserState)">
<summary>
 Get the state.
</summary>
</member>
<member name="M:Prime.UserStateModule.UserStateModule.getImperative(Prime.UserStateModule.UserState)">
<summary>
 Check that the user state is imperative.
</summary>
</member>
<member name="M:Prime.XtensionModule.Xtension.tryGetDefaultValue``1(Prime.XtensionModule.Xtension,System.String)">
<summary>
 Try to get the default value for a given xtension member, returning None when defaulting is disallowed.
</summary>
</member>
<member name="M:Prime.XtensionModule.Xtension.op_DynamicAssignment``1(Prime.XtensionModule.Xtension,System.String,``0)">
<summary>
 The dynamic assignment operator for an Xtension.
 Example:
     let xtn = xtn.Position &lt;- Vector2 (4.0, 5.0).
</summary>
</member>
<member name="M:Prime.XtensionModule.Xtension.op_Dynamic``1(Prime.XtensionModule.Xtension,System.String)">
<summary>
 The dynamic look-up operator for an Xtension.
 Example:
     let parallax = xtn?Parallax : single
</summary>
</member>
<member name="T:Prime.XtensionModule.Xtension">
<summary>
 Xtensions are a dynamic, functional, and convenient way to implement both dynamic properties
 and designer properties.
</summary>
</member>
<member name="M:Prime.XtensionModule.XtensionModule.ofSeq(System.Collections.Generic.IEnumerable{System.Tuple{System.String,Prime.Property}})">
<summary>
 Convert an xtension to a sequence of its entries.
</summary>
</member>
<member name="M:Prime.XtensionModule.XtensionModule.toSeq(Prime.XtensionModule.Xtension)">
<summary>
 Convert an xtension to a sequence of its entries.
</summary>
</member>
<member name="M:Prime.XtensionModule.XtensionModule.detachProperties(System.Collections.Generic.IEnumerable{System.String},Prime.XtensionModule.Xtension)">
<summary>
 Detach multiple properties from an Xtension.
</summary>
</member>
<member name="M:Prime.XtensionModule.XtensionModule.detachProperty(System.String,Prime.XtensionModule.Xtension)">
<summary>
 Detach a property from an Xtension.
</summary>
</member>
<member name="M:Prime.XtensionModule.XtensionModule.attachProperties(System.Collections.Generic.IEnumerable{System.Tuple{System.String,Prime.Property}},Prime.XtensionModule.Xtension)">
<summary>
 Attach multiple properties to an Xtension.
</summary>
</member>
<member name="M:Prime.XtensionModule.XtensionModule.attachProperty(System.String,Prime.Property,Prime.XtensionModule.Xtension)">
<summary>
 Attach a property to an Xtension.
</summary>
</member>
<member name="M:Prime.XtensionModule.XtensionModule.setProperty(System.String,Prime.Property,Prime.XtensionModule.Xtension)">
<summary>
 Set a property on an Xtension.
</summary>
</member>
<member name="M:Prime.XtensionModule.XtensionModule.trySetProperty(System.String,Prime.Property,Prime.XtensionModule.Xtension)">
<summary>
 Set a property on an Xtension.
</summary>
</member>
<member name="M:Prime.XtensionModule.XtensionModule.getProperty(System.String,Prime.XtensionModule.Xtension)">
<summary>
 Get a property from an xtension.
</summary>
</member>
<member name="M:Prime.XtensionModule.XtensionModule.tryGetProperty(System.String,Prime.XtensionModule.Xtension)">
<summary>
 Try to get a property from an xtension.
</summary>
</member>
<member name="M:Prime.XtensionModule.XtensionModule.getImperative(Prime.XtensionModule.Xtension)">
<summary>
 Whether the extension uses mutation.
</summary>
</member>
<member name="M:Prime.XtensionModule.XtensionModule.makeMixed">
<summary>
 An Xtension that cannot default, isn&apos;t sealed, and isn&apos;t imperative.
</summary>
</member>
<member name="M:Prime.XtensionModule.XtensionModule.makeSafe">
<summary>
 An Xtension that cannot default, is sealed, and isn&apos;t imperative.
</summary>
</member>
<member name="M:Prime.XtensionModule.XtensionModule.makeEmpty">
<summary>
 An Xtension that can default, isn&apos;t sealed, and isn&apos;t imperative.
</summary>
</member>
<member name="M:Prime.XtensionModule.XtensionModule.makeImperative">
<summary>
 An Xtension that cannot default, is sealed, and is imperative.
</summary>
</member>
<member name="M:Prime.XtensionModule.XtensionModule.make(Prime.UMapModule.UMap{System.String,Prime.Property},System.Boolean,System.Boolean,System.Boolean)">
<summary>
 Make an extension.
</summary>
</member>
<member name="P:Prime.XtensionModule.XtensionModule.Config">
<summary>
 The TConfig of Xtension&apos;s T/U structures.
</summary>
</member>
<member name="T:Prime.EventFilter.Filter">
<summary>
 Describes how events are filtered.
</summary>
</member>
<member name="M:Prime.EventFilter.filter(System.String,Microsoft.FSharp.Collections.FSharpList{Prime.EventInfo},Prime.EventFilter.Filter)">
<summary>
 Filter events.
</summary>
</member>
<member name="T:Prime.EventSystemModule.EventSystem`1">
<summary>
 A publisher-neutral, purely functional event system.
 OPTIMIZATION: EventContext mutable for speed.
</summary>
</member>
<member name="M:Prime.EventSystemModule.EventSystem.make``1(Microsoft.FSharp.Core.FSharpFunc{System.String,Microsoft.FSharp.Core.Unit},System.Boolean,Prime.EventFilter.Filter,Prime.Participant)">
<summary>
 Make an event system.
</summary>
</member>
<member name="M:Prime.EventSystemModule.EventSystem.getEventAddresses``1(Prime.EventSystemModule.EventSystem{``0})">
<summary>
 Get the current event address list for cycle-detection.
</summary>
</member>
<member name="M:Prime.EventSystemModule.EventSystem.popEventAddress``1(Prime.EventSystemModule.EventSystem{``0})">
<summary>
 Pop an event address to the list for cycle-detection.
</summary>
</member>
<member name="M:Prime.EventSystemModule.EventSystem.pushEventAddress``1(Prime.AddressModule.Address{System.Object},Prime.EventSystemModule.EventSystem{``0})">
<summary>
 Push an event address to the list for cycle-detection.
</summary>
</member>
<member name="M:Prime.EventSystemModule.EventSystem.logEvent``1(Prime.AddressModule.Address{System.Object},Microsoft.FSharp.Collections.FSharpList{Prime.EventInfo},Prime.EventSystemModule.EventSystem{``0})">
<summary>
 Log an event.
</summary>
</member>
<member name="M:Prime.EventSystemModule.EventSystem.setEventContext``1(Prime.Participant,Prime.EventSystemModule.EventSystem{``0})">
<summary>
 Set the context of the event system.
</summary>
</member>
<member name="M:Prime.EventSystemModule.EventSystem.qualifyEventContext``1(Prime.AddressModule.Address{System.Object},Prime.EventSystemModule.EventSystem{``0})">
<summary>
 Qualify the event context of the world.
</summary>
</member>
<member name="M:Prime.EventSystemModule.EventSystem.getGlobalPariticipant``1(Prime.EventSystemModule.EventSystem{``0})">
<summary>
 Get the global participant of the event system.
</summary>
</member>
<member name="M:Prime.EventSystemModule.EventSystem.getEventContext``1(Prime.EventSystemModule.EventSystem{``0})">
<summary>
 Get the context of the event system.
</summary>
</member>
<member name="M:Prime.EventSystemModule.EventSystem.setEventFilter``1(Prime.EventFilter.Filter,Prime.EventSystemModule.EventSystem{``0})">
<summary>
 Set the state of the event filter.
</summary>
</member>
<member name="M:Prime.EventSystemModule.EventSystem.getEventFilter``1(Prime.EventSystemModule.EventSystem{``0})">
<summary>
 Get the state of the event filter.
</summary>
</member>
<member name="M:Prime.EventSystemModule.EventSystem.setEventTracing``1(System.Boolean,Prime.EventSystemModule.EventSystem{``0})">
<summary>
 Set whether events are being traced.
</summary>
</member>
<member name="M:Prime.EventSystemModule.EventSystem.getEventTracing``1(Prime.EventSystemModule.EventSystem{``0})">
<summary>
 Get whether events are being traced.
</summary>
</member>
<member name="M:Prime.EventSystemModule.EventSystem.getEventState``2(System.Guid,Prime.EventSystemModule.EventSystem{``1})">
<summary>
 Get event state.
</summary>
</member>
<member name="M:Prime.EventSystemModule.EventSystem.setUnsubscriptions``1(Prime.UMapModule.UMap{System.Guid,System.Tuple{Prime.AddressModule.Address{System.Object},Prime.Participant}},Prime.EventSystemModule.EventSystem{``0})">
<summary>
 Set unsubscriptions.
</summary>
</member>
<member name="M:Prime.EventSystemModule.EventSystem.setSubscriptions``1(Prime.UMapModule.UMap{Prime.AddressModule.Address{System.Object},Prime.SubscriptionEntry[]},Prime.EventSystemModule.EventSystem{``0})">
<summary>
 Set subscriptions.
</summary>
</member>
<member name="M:Prime.EventSystemModule.EventSystem.getUnsubscriptions``1(Prime.EventSystemModule.EventSystem{``0})">
<summary>
 Get unsubscriptions.
</summary>
</member>
<member name="M:Prime.EventSystemModule.EventSystem.getSubscriptions``1(Prime.EventSystemModule.EventSystem{``0})">
<summary>
 Get subscriptions.
</summary>
</member>
<member name="M:Prime.EventSystemModule.EventSystem.removeEventState``1(System.Guid,Prime.EventSystemModule.EventSystem{``0})">
<summary>
 Remove event state.
</summary>
</member>
<member name="M:Prime.EventSystemModule.EventSystem.addEventState``2(System.Guid,``0,Prime.EventSystemModule.EventSystem{``1})">
<summary>
 Add event state.
</summary>
</member>
<member name="P:Prime.EventSystemModule.EventSystem.Config">
<summary>
 The TConfig of Xtension&apos;s T/U structures.
</summary>
</member>
<member name="P:Prime.Events.Wildcard">
<summary>
 Represents a wildcard in an event.
</summary>
</member>
<member name="M:Prime.EventWorld.monitor``4(Microsoft.FSharp.Core.FSharpFunc{Prime.Event{``0,``1},Microsoft.FSharp.Core.FSharpFunc{``3,``3}},Prime.AddressModule.Address{``0},``1,``3)">
<summary>
 Keep active a subscription for the life span of a participant.
</summary>
</member>
<member name="M:Prime.EventWorld.monitorPlus``4(Microsoft.FSharp.Core.FSharpFunc{Prime.Event{``0,``1},Microsoft.FSharp.Core.FSharpFunc{``3,System.Tuple{Prime.Handling,``3}}},Prime.AddressModule.Address{``0},``1,``3)">
<summary>
 Keep active a subscription for the life span of a participant, and be provided with an unsubscription callback.
</summary>
</member>
<member name="M:Prime.EventWorld.subscribe``4(Microsoft.FSharp.Core.FSharpFunc{Prime.Event{``0,``1},Microsoft.FSharp.Core.FSharpFunc{``3,``3}},Prime.AddressModule.Address{``0},``1,``3)">
<summary>
 Subscribe to an event.
</summary>
</member>
<member name="M:Prime.EventWorld.subscribePlus``4(System.Guid,Microsoft.FSharp.Core.FSharpFunc{Prime.Event{``0,``1},Microsoft.FSharp.Core.FSharpFunc{``3,System.Tuple{Prime.Handling,``3}}},Prime.AddressModule.Address{``0},``1,``3)">
<summary>
 Subscribe to an event using the given subscriptionKey, and be provided with an unsubscription callback.
</summary>
</member>
<member name="M:Prime.EventWorld.unsubscribe``2(System.Guid,``1)">
<summary>
 Unsubscribe from an event.
</summary>
</member>
<member name="M:Prime.EventWorld.publish``4(``0,Prime.AddressModule.Address{``0},Microsoft.FSharp.Collections.FSharpList{Prime.EventInfo},``1,``3)">
<summary>
 Publish an event with no subscription sorting.
</summary>
</member>
<member name="M:Prime.EventWorld.publishPlus``4(Microsoft.FSharp.Core.FSharpFunc{Prime.SubscriptionEntry[],Microsoft.FSharp.Core.FSharpFunc{``3,Prime.SubscriptionEntry[]}},``0,Prime.AddressModule.Address{``0},Microsoft.FSharp.Collections.FSharpList{Prime.EventInfo},``1,System.Boolean,``3)">
<summary>
 Publish an event, using the given publishSorter procedures to arrange the order to which subscriptions are published.
</summary>
</member>
<member name="M:Prime.EventWorld.sortSubscriptionsNone``1(Prime.SubscriptionEntry[],``0)">
<summary>
 A &apos;no-op&apos; for subscription sorting - that is, performs no sorting at all.
</summary>
</member>
<member name="M:Prime.EventWorld.sortSubscriptionsBy``1(Microsoft.FSharp.Core.FSharpFunc{Prime.Participant,Microsoft.FSharp.Core.FSharpFunc{``0,System.IComparable}},Prime.SubscriptionEntry[],``0)">
<summary>
 Sort subscriptions using categorization via the &apos;by&apos; procedure.
</summary>
</member>
<member name="M:Prime.EventWorld.publishEvent``5(Prime.Participant,``1,``0,Prime.AddressModule.Address{``0},Microsoft.FSharp.Collections.FSharpList{Prime.EventInfo},System.Object,``4)">
<summary>
 Publish an event directly.
</summary>
</member>
<member name="M:Prime.EventWorld.cleanEventAddressCache``1(Prime.AddressModule.Address{``0})">
<summary>
 Remove from the event address cache all addresses belonging to the given target.
</summary>
</member>
<member name="M:Prime.EventWorld.setEventAddressCaching(System.Boolean)">
<summary>
 Set whether event addresses are cached internally.
 If you enable caching, be sure to use EventWorld.cleanEventAddressCache to keep the cache from expanding
 indefinitely.
</summary>
</member>
<member name="M:Prime.EventWorld.qualifyEventContext``2(Prime.AddressModule.Address{System.Object},``1)">
<summary>
 Qualify the event context of the world.
</summary>
</member>
<member name="M:Prime.EventWorld.setEventContext``2(Prime.Participant,``1)">
<summary>
 Set the event context of the world.
</summary>
</member>
<member name="M:Prime.EventWorld.getEventContext``2(``1)">
<summary>
 Get the event context of the world.
</summary>
</member>
<member name="M:Prime.EventWorld.setEventFilter``2(Prime.EventFilter.Filter,``1)">
<summary>
 Set the state of the event filter.
</summary>
</member>
<member name="M:Prime.EventWorld.getEventFilter``2(``1)">
<summary>
 Get the state of the event filter.
</summary>
</member>
<member name="M:Prime.EventWorld.setEventTracing``2(System.Boolean,``1)">
<summary>
 Set whether events are being traced.
</summary>
</member>
<member name="M:Prime.EventWorld.getEventTracing``2(``1)">
<summary>
 Get whether events are being traced.
</summary>
</member>
<member name="M:Prime.EventWorld.getEventState``3(System.Guid,``2)">
<summary>
 Get event state from the world.
</summary>
</member>
<member name="M:Prime.EventWorld.removeEventState``2(System.Guid,``1)">
<summary>
 Remove event state from the world.
</summary>
</member>
<member name="M:Prime.EventWorld.addEventState``3(System.Guid,``0,``2)">
<summary>
 Add event state to the world.
</summary>
</member>
<member name="M:Prime.EventWorld.setUnsubscriptions``2(Prime.UMapModule.UMap{System.Guid,System.Tuple{Prime.AddressModule.Address{System.Object},Prime.Participant}},``1)">
<summary>
 Set event unsubscriptions.
</summary>
</member>
<member name="M:Prime.EventWorld.setSubscriptions``2(Prime.UMapModule.UMap{Prime.AddressModule.Address{System.Object},Prime.SubscriptionEntry[]},``1)">
<summary>
 Set event subscriptions.
</summary>
</member>
<member name="M:Prime.EventWorld.getUnsubscriptions``2(``1)">
<summary>
 Get event unsubscriptions.
</summary>
</member>
<member name="M:Prime.EventWorld.getSubscriptions``2(``1)">
<summary>
 Get event subscriptions.
</summary>
</member>
<member name="M:Prime.EventWorld.updateEventSystem``2(Microsoft.FSharp.Core.FSharpFunc{Prime.EventSystemModule.EventSystem{``1},Prime.EventSystemModule.EventSystem{``1}},``1)">
<summary>
 Update the event system in the world.
</summary>
</member>
<member name="M:Prime.EventWorld.getEventSystemBy``3(Microsoft.FSharp.Core.FSharpFunc{Prime.EventSystemModule.EventSystem{``2},``0},``2)">
<summary>
 Get the event system as tranformed via &apos;by&apos;.
</summary>
</member>
<member name="M:Prime.EventWorld.getEventSystem``2(``1)">
<summary>
 Get the event system.
</summary>
</member>
<member name="M:Prime.StreamOperators.op_MinusMinusGreater``4(Prime.Stream{``0,``1,``2},Prime.PropertyTag{``3,``0,``2})">
<summary>
 Propagate the event data of a stream to a property in the observing participant when the
 subscriber exists (doing nothing otherwise).
</summary>
</member>
<member name="M:Prime.StreamOperators.op_BangMinusMinus``4(Prime.PropertyTag{``0,``1,``2})">
<summary>
 Make a stream of the subscriber&apos;s change events.
</summary>
</member>
<member name="M:Prime.StreamOperators.op_MinusMinusMinus``2">
<summary>
 Stream sequencing operator.
</summary>
</member>
<member name="M:Prime.Stream.distinct``3(Prime.Stream{``0,``1,``2})">
<summary>
 Filter out the events with non-unique data from a stream.
</summary>
</member>
<member name="M:Prime.Stream.distinctBy``4(Microsoft.FSharp.Core.FSharpFunc{``0,``1},Prime.Stream{``0,``2,``3})">
<summary>
 Filter out the events with non-unique data as defined via &apos;by&apos; from a stream.
</summary>
</member>
<member name="M:Prime.Stream.min``3(Prime.Stream{``0,``1,``2})">
<summary>
 Transform a stream into a running minimum of it numeric data.
</summary>
</member>
<member name="M:Prime.Stream.max``3(Prime.Stream{``0,``1,``2})">
<summary>
 Transform a stream into a running maximum of it numeric data.
</summary>
</member>
<member name="M:Prime.Stream.choose``3(Prime.Stream{Microsoft.FSharp.Core.FSharpOption{``0},``1,``2})">
<summary>
 Filter out the None data values from a stream and strip the Some constructor from
 the remaining values.
</summary>
</member>
<member name="M:Prime.Stream.search``3(Microsoft.FSharp.Core.FSharpFunc{``0,System.Boolean},Prime.Stream{``0,``1,``2})">
<summary>
 Take only the first event from a stream that satisfies &apos;p&apos;.
</summary>
</member>
<member name="M:Prime.Stream.nth``3(System.Int32,Prime.Stream{``0,``1,``2})">
<summary>
 Take only the nth event from a stream.
</summary>
</member>
<member name="M:Prime.Stream.tail``3(Prime.Stream{``0,``1,``2})">
<summary>
 Skip the first event of a stream.
</summary>
</member>
<member name="M:Prime.Stream.head``3(Prime.Stream{``0,``1,``2})">
<summary>
 Take only the first event from a stream.
</summary>
</member>
<member name="M:Prime.Stream.skip``3(System.Int32,Prime.Stream{``0,``1,``2})">
<summary>
 Skip the first n events in a stream.
</summary>
</member>
<member name="M:Prime.Stream.take``3(System.Int32,Prime.Stream{``0,``1,``2})">
<summary>
 Take only the first n events from a stream.
</summary>
</member>
<member name="M:Prime.Stream.duplicate``3(Prime.Stream{``0,``1,``2})">
<summary>
 Transform a stream by duplicating its data into pairs.
</summary>
</member>
<member name="M:Prime.Stream.mapSecond``5(Microsoft.FSharp.Core.FSharpFunc{``0,``1},Prime.Stream{System.Tuple{``2,``0},``3,``4})">
<summary>
 Transform a stream of pairs by a mapping of its snd values.
</summary>
</member>
<member name="M:Prime.Stream.mapFirst``5(Microsoft.FSharp.Core.FSharpFunc{``0,``1},Prime.Stream{System.Tuple{``0,``2},``3,``4})">
<summary>
 Transform a stream&apos;s pairs by a mapping of its fst values.
</summary>
</member>
<member name="M:Prime.Stream.second``4(Prime.Stream{System.Tuple{``0,``1},``2,``3})">
<summary>
 Transform a stream of pairs into its snd values.
</summary>
</member>
<member name="M:Prime.Stream.first``4(Prime.Stream{System.Tuple{``0,``1},``2,``3})">
<summary>
 Transform a stream of pairs into its fst values.
</summary>
</member>
<member name="M:Prime.Stream.productN``3(Prime.Stream{``0,``1,``2})">
<summary>
 Transform a stream into a running product of its data.
</summary>
</member>
<member name="M:Prime.Stream.sumN``3(Prime.Stream{``0,``1,``2})">
<summary>
 Transform a stream into a running sum of its data.
</summary>
</member>
<member name="M:Prime.Stream.group``3(Prime.Stream{``0,``1,``2})">
<summary>
 Transform a stream into a running set of its event&apos;s unique data.
</summary>
</member>
<member name="M:Prime.Stream.groupBy``4(Microsoft.FSharp.Core.FSharpFunc{``0,``1},Prime.Stream{``0,``2,``3})">
<summary>
 Transform a stream into a running set of its event&apos;s unique data as defined via &apos;by&apos;.
</summary>
</member>
<member name="M:Prime.Stream.organize``4(Microsoft.FSharp.Core.FSharpFunc{``0,``1},Prime.Stream{``0,``2,``3})">
<summary>
 Transform a stream into a running map from its event&apos;s data to keys as defined by &apos;f&apos;.
</summary>
</member>
<member name="M:Prime.Stream.average``6(Prime.Stream{``0,``4,``5})">
<summary>
 Transform a stream into a running average of its event&apos;s numeric data.
</summary>
</member>
<member name="M:Prime.Stream.monitor``4(Microsoft.FSharp.Core.FSharpFunc{Prime.Event{``0,``1},Microsoft.FSharp.Core.FSharpFunc{``2,``2}},``1,Prime.Stream{``0,``3,``2},``2)">
<summary>
 Subscribe to a stream until the subscriber is removed from the world.
</summary>
</member>
<member name="M:Prime.Stream.monitorPlus``4(Microsoft.FSharp.Core.FSharpFunc{Prime.Event{``0,``1},Microsoft.FSharp.Core.FSharpFunc{``2,System.Tuple{Prime.Handling,``2}}},``1,Prime.Stream{``0,``3,``2},``2)">
<summary>
 Subscribe to a stream until the subscriber is removed from the world,
 returning both an unsubscription procedure as well as the world as augmented with said
 subscription.
</summary>
</member>
<member name="M:Prime.Stream.subscribe``4(Microsoft.FSharp.Core.FSharpFunc{Prime.Event{``0,``1},Microsoft.FSharp.Core.FSharpFunc{``2,``2}},``1,Prime.Stream{``0,``3,``2},``2)">
<summary>
 Subscribe to a stream, handling each event with the given subscription.
</summary>
</member>
<member name="M:Prime.Stream.subscribePlus``4(Microsoft.FSharp.Core.FSharpFunc{Prime.Event{``0,``1},Microsoft.FSharp.Core.FSharpFunc{``2,System.Tuple{Prime.Handling,``2}}},``1,Prime.Stream{``0,``3,``2},``2)">
<summary>
 Subscribe to a stream, handling each event with the given subscription,
 returning both an unsubscription procedure as well as the world as augmented with said
 subscription.
</summary>
</member>
<member name="M:Prime.Stream.lifetime``4(``0,Prime.Stream{``1,``2,``3})">
<summary>
 Terminate a stream when the subscriber is unregistered from the world.
</summary>
</member>
<member name="M:Prime.Stream.until``4(Prime.Stream{``0,``1,``2},Prime.Stream{``3,``1,``2})">
<summary>
 Terminate a stream when a given stream receives a value.
</summary>
</member>
<member name="M:Prime.Stream.sum``4(Prime.Stream{``0,``1,``2},Prime.Stream{``3,``1,``2})">
<summary>
 Combine two streams. Combination is in &apos;sum form&apos;, which is defined as an Either of the data of the combined
 events, where only data from the most recent event is available at a time.
</summary>
</member>
<member name="M:Prime.Stream.product``4(Prime.Stream{``0,``1,``2},Prime.Stream{``3,``1,``2})">
<summary>
 Combine two streams. Combination is in &apos;product form&apos;, which is defined as a pair of the data of the combined
 events. Think of it as &apos;zip&apos; for event streams.
</summary>
</member>
<member name="M:Prime.Stream.map``4(Microsoft.FSharp.Core.FSharpFunc{``0,``1},Prime.Stream{``0,``2,``3})">
<summary>
 Map over a stream by the given &apos;mapper&apos; procedure.
</summary>
</member>
<member name="M:Prime.Stream.filter``3(Microsoft.FSharp.Core.FSharpFunc{``0,System.Boolean},Prime.Stream{``0,``1,``2})">
<summary>
 Filter a stream by the given &apos;pred&apos; procedure.
</summary>
</member>
<member name="M:Prime.Stream.reduce``3(Microsoft.FSharp.Core.FSharpFunc{``0,Microsoft.FSharp.Core.FSharpFunc{``0,``0}},Prime.Stream{``0,``1,``2})">
<summary>
 Reduce over a stream, accumulating the result.
</summary>
</member>
<member name="M:Prime.Stream.fold``4(Microsoft.FSharp.Core.FSharpFunc{``0,Microsoft.FSharp.Core.FSharpFunc{``1,``0}},``0,Prime.Stream{``1,``2,``3})">
<summary>
 Fold over a stream, aggegating the result.
</summary>
</member>
<member name="M:Prime.Stream.foldMap``5(Microsoft.FSharp.Core.FSharpFunc{``0,Microsoft.FSharp.Core.FSharpFunc{``1,``0}},Microsoft.FSharp.Core.FSharpFunc{``0,``2},``0,Prime.Stream{``1,``3,``4})">
<summary>
 Fold over a stream, then map the result.
</summary>
</member>
<member name="M:Prime.Stream.mapWorld``4(Microsoft.FSharp.Core.FSharpFunc{``0,Microsoft.FSharp.Core.FSharpFunc{``1,``3}},Prime.Stream{``0,``2,``1})">
<summary>
 Map over a stream by the given &apos;mapper&apos; procedure.
</summary>
</member>
<member name="M:Prime.Stream.filterWorld``3(Microsoft.FSharp.Core.FSharpFunc{``0,Microsoft.FSharp.Core.FSharpFunc{``1,System.Boolean}},Prime.Stream{``0,``2,``1})">
<summary>
 Filter a stream by the given &apos;pred&apos; procedure.
</summary>
</member>
<member name="M:Prime.Stream.reduceWorld``3(Microsoft.FSharp.Core.FSharpFunc{``0,Microsoft.FSharp.Core.FSharpFunc{``0,Microsoft.FSharp.Core.FSharpFunc{``1,``0}}},Prime.Stream{``0,``2,``1})">
<summary>
 Reduce over a stream, accumulating the result.
</summary>
</member>
<member name="M:Prime.Stream.foldWorld``4(Microsoft.FSharp.Core.FSharpFunc{``0,Microsoft.FSharp.Core.FSharpFunc{``1,Microsoft.FSharp.Core.FSharpFunc{``2,``0}}},``0,Prime.Stream{``1,``3,``2})">
<summary>
 Fold over a stream, aggegating the result.
</summary>
</member>
<member name="M:Prime.Stream.foldMapWorld``5(Microsoft.FSharp.Core.FSharpFunc{``0,Microsoft.FSharp.Core.FSharpFunc{``1,Microsoft.FSharp.Core.FSharpFunc{``2,``0}}},Microsoft.FSharp.Core.FSharpFunc{``0,``4},``0,Prime.Stream{``1,``3,``2})">
<summary>
 Fold over a stream, then map the result.
</summary>
</member>
<member name="M:Prime.Stream.mapEvent``4(Microsoft.FSharp.Core.FSharpFunc{Prime.Event{``0,``1},Microsoft.FSharp.Core.FSharpFunc{``2,``3}},Prime.Stream{``0,``1,``2})">
<summary>
 Map over a stream by the given &apos;mapper&apos; procedure.
</summary>
</member>
<member name="M:Prime.Stream.filterEvent``3(Microsoft.FSharp.Core.FSharpFunc{Prime.Event{``0,``1},Microsoft.FSharp.Core.FSharpFunc{``2,System.Boolean}},Prime.Stream{``0,``1,``2})">
<summary>
 Filter a stream by the given &apos;pred&apos; procedure.
</summary>
</member>
<member name="M:Prime.Stream.reduceEvent``3(Microsoft.FSharp.Core.FSharpFunc{``0,Microsoft.FSharp.Core.FSharpFunc{Prime.Event{``0,``1},Microsoft.FSharp.Core.FSharpFunc{``2,``0}}},Prime.Stream{``0,``1,``2})">
<summary>
 Reduce over a stream, accumulating the result.
</summary>
</member>
<member name="M:Prime.Stream.foldEvent``4(Microsoft.FSharp.Core.FSharpFunc{``0,Microsoft.FSharp.Core.FSharpFunc{Prime.Event{``1,``2},Microsoft.FSharp.Core.FSharpFunc{``3,``0}}},``0,Prime.Stream{``1,``2,``3})">
<summary>
 Fold over a stream, aggegating the result.
</summary>
</member>
<member name="M:Prime.Stream.foldMapEvent``5(Microsoft.FSharp.Core.FSharpFunc{``0,Microsoft.FSharp.Core.FSharpFunc{Prime.Event{``1,``2},Microsoft.FSharp.Core.FSharpFunc{``3,``0}}},Microsoft.FSharp.Core.FSharpFunc{``0,``4},``0,Prime.Stream{``1,``2,``3})">
<summary>
 Fold over a stream, then map the result.
</summary>
</member>
<member name="M:Prime.Stream.stream``3(Prime.AddressModule.Address{``0})">
<summary>
 Make a stream of an event at the given address.
</summary>
</member>
<member name="M:Prime.Chain.runAssumingResolve``3(Prime.Chain{Prime.Event{``0,``1},Microsoft.FSharp.Core.Unit,``1,``2},Prime.Stream{``0,``1,``2},``2)">
<summary>
 Run a chain over Nu&apos;s event system.
 Allows each chainhronized operation to run without referencing its source event, and
 without specifying its event handling approach by assuming Resolve.
</summary>
</member>
<member name="M:Prime.Chain.runAssumingCascade``3(Prime.Chain{Prime.Event{``0,``1},Microsoft.FSharp.Core.Unit,``1,``2},Prime.Stream{``0,``1,``2},``2)">
<summary>
 Run a chain over Nu&apos;s event system.
 Allows each chainhronized operation to run without referencing its source event, and
 without specifying its event handling approach by assuming Cascade.
</summary>
</member>
<member name="M:Prime.Chain.run``3(Prime.Chain{Microsoft.FSharp.Core.Unit,``0,``1,``2},``2)">
<summary>
 Run a chain to its end, providing unit for all its steps.
</summary>
</member>
<member name="M:Prime.Chain.run2``3(Prime.Chain{Microsoft.FSharp.Core.Unit,``0,``1,``2},``2)">
<summary>
 Run a chain to its end, providing unit for all its steps.
</summary>
</member>
<member name="M:Prime.Chain.run3``4(Prime.Chain{``0,``1,``2,``3},``0,``3)">
<summary>
 Run a chain to its end, providing &apos;e&apos; for all its steps.
</summary>
</member>
<member name="M:Prime.Chain.advance``4(Microsoft.FSharp.Core.FSharpFunc{``0,Prime.Chain{``0,``1,``2,``3}},``0,``3)">
<summary>
 Advance a chain value by one step, providing &apos;e&apos;.
</summary>
</member>
<member name="M:Prime.Chain.step``4(Prime.Chain{``0,``1,``2,``3},``3)">
<summary>
 Step once into a chain.
</summary>
</member>
<member name="M:Prime.Chain.during``3(Microsoft.FSharp.Core.FSharpFunc{``0,System.Boolean},Prime.Chain{``2,Microsoft.FSharp.Core.Unit,``1,``0})">
<summary>
 Loop in a chain context while &apos;pred&apos; evaluates to true.
</summary>
</member>
<member name="M:Prime.Chain.loop``4(``0,Microsoft.FSharp.Core.FSharpFunc{``0,``0},Microsoft.FSharp.Core.FSharpFunc{``0,Microsoft.FSharp.Core.FSharpFunc{``1,System.Boolean}},Microsoft.FSharp.Core.FSharpFunc{``0,Prime.Chain{``3,Microsoft.FSharp.Core.Unit,``2,``1}})">
<summary>
 Loop in a chain context while &apos;pred&apos; evaluate to true.
</summary>
</member>
<member name="M:Prime.Chain.react``3(Microsoft.FSharp.Core.FSharpFunc{``0,``0})">
<summary>
 React to the next event, discarding the event&apos;s value.
</summary>
</member>
<member name="M:Prime.Chain.reactE``3(Microsoft.FSharp.Core.FSharpFunc{``0,Microsoft.FSharp.Core.FSharpFunc{``1,``1}})">
<summary>
 React to the next event, using the event&apos;s value in the reaction.
</summary>
</member>
<member name="M:Prime.Chain.pass``3">
<summary>
 Pass over the next event.
</summary>
</member>
<member name="M:Prime.Chain.next``3">
<summary>
 Get the next event.
</summary>
</member>
<member name="M:Prime.Chain.update``3(Microsoft.FSharp.Core.FSharpFunc{``0,``0})">
<summary>
 Update the world.
</summary>
</member>
<member name="M:Prime.Chain.updateBy``4(Microsoft.FSharp.Core.FSharpFunc{``0,``2},Microsoft.FSharp.Core.FSharpFunc{``2,Microsoft.FSharp.Core.FSharpFunc{``0,``0}})">
<summary>
 Update the world with an additional transformed world parameter.
</summary>
</member>
<member name="M:Prime.Chain.set``3(``0)">
<summary>
 Set the world.
</summary>
</member>
<member name="M:Prime.Chain.getBy``4(Microsoft.FSharp.Core.FSharpFunc{``0,``2})">
<summary>
 Get the world as transformed via &apos;by&apos;.
</summary>
</member>
<member name="M:Prime.Chain.get``3">
<summary>
 Get the world.
</summary>
</member>
<member name="M:Prime.Chain.bind``5(Prime.Chain{``0,``1,``2,``3},Microsoft.FSharp.Core.FSharpFunc{``1,Prime.Chain{``0,``4,``2,``3}})">
<summary>
 Monadic bind for the chain monad.
</summary>
</member>
<member name="M:Prime.Chain.returnM``4(``0)">
<summary>
 Monadic return for the chain monad.
</summary>
</member>
<member name="P:Prime.ChainBuilderModule.chain">
<summary>
 Builds the chain monad.
</summary>
</member>
<member name="T:Prime.Scripting.Env">
<summary>
 The execution environment for scripts.
</summary>
</member>
<member name="T:Prime.Scripting.AddType">
<summary>
 The manner in which bindings are added to a frame.
</summary>
</member>
<member name="T:Prime.Scripting.ProceduralFrame">
<summary>
 A declaration bindings frame in a scripting environment.
</summary>
</member>
<member name="T:Prime.Scripting.DeclarationFrame">
<summary>
 A declaration bindings frame in a scripting environment.
</summary>
</member>
<member name="T:Prime.Scripting.ExprConverter">
<summary>
 Converts Expr types.
</summary>
</member>
<member name="P:Prime.Scripting.NoneValue">
<summary>
 The none value in scripting.
</summary>
</member>
<member name="P:Prime.Scripting.FalseValue">
<summary>
 The false value in scripting.
</summary>
</member>
<member name="P:Prime.Scripting.TrueValue">
<summary>
 The true value in scripting.
</summary>
</member>
<member name="T:Prime.Scripting.EnvModule.Env">
<summary>
 The execution environment for scripts.
</summary>
</member>
<member name="M:Prime.ScriptingWorld.tryEvalScript``2(Microsoft.FSharp.Core.FSharpFunc{``0,``1},System.String,``0)">
<summary>
 Attempt to evaluate a script.
</summary>
</member>
<member name="M:Prime.ScriptingWorld.evalManyWithLogging``1(Prime.Scripting.Expr[],``0)">
<summary>
 Evaluate a series of expressions, with logging on violation result.
</summary>
</member>
<member name="M:Prime.ScriptingWorld.evalWithLogging``1(Prime.Scripting.Expr,``0)">
<summary>
 Evaluate an expression, with logging on violation result.
</summary>
</member>
<member name="M:Prime.ScriptingWorld.evalMany``1(Prime.Scripting.Expr[],``0)">
<summary>
 Evaluate a sequence of expressions.
</summary>
</member>
<member name="M:Prime.ScriptingWorld.eval``1(Prime.Scripting.Expr,``0)">
<summary>
 Evaluate an expression.
</summary>
</member>
<member name="M:Prime.Tests.ListTests.aryEqListsLookingBackwards(System.Collections.Generic.List{System.Int32},Prime.Tests.ListTests.ListAction{System.Int32}[])">
<summary>
 Proof of concept, we can delete this after we know test is correct
</summary>
</member>
<member name="M:Prime.Tests.ListTests.eqListsAfterSteps``2(System.Collections.Generic.List{``0},``1,Prime.Tests.ListTests.ListAction{``0}[],Microsoft.FSharp.Core.FSharpFunc{``0,Microsoft.FSharp.Core.FSharpFunc{``1,``1}},Microsoft.FSharp.Core.FSharpFunc{System.Int32,Microsoft.FSharp.Core.FSharpFunc{``1,``0}},Microsoft.FSharp.Core.FSharpFunc{System.Int32,Microsoft.FSharp.Core.FSharpFunc{``0,Microsoft.FSharp.Core.FSharpFunc{``1,``1}}},Microsoft.FSharp.Core.FSharpFunc{``0,``0},Microsoft.FSharp.Core.FSharpFunc{Microsoft.FSharp.Core.FSharpFunc{``0,``0},Microsoft.FSharp.Core.FSharpFunc{``1,``1}},Microsoft.FSharp.Core.FSharpFunc{``0,System.Boolean},Microsoft.FSharp.Core.FSharpFunc{Microsoft.FSharp.Core.FSharpFunc{``0,System.Boolean},Microsoft.FSharp.Core.FSharpFunc{``1,``1}},Microsoft.FSharp.Core.FSharpFunc{``1,Microsoft.FSharp.Core.FSharpFunc{System.Collections.Generic.List{``0},System.Boolean}},System.Boolean)">
<summary>
 Keeps a reference to all persistent collections returned after
 performing actions, and after they are all applied, checks
 that they equal what we would get from FSharp.Core.List
</summary>
</member>
<member name="M:Prime.Tests.MapTests.eqMapsAfterSteps``3(Microsoft.FSharp.Collections.FSharpMap{``0,``1},``2,Prime.Tests.MapTests.MapAction{``0,``1}[],Microsoft.FSharp.Core.FSharpFunc{``0,Microsoft.FSharp.Core.FSharpFunc{``1,Microsoft.FSharp.Core.FSharpFunc{``2,``2}}},Microsoft.FSharp.Core.FSharpFunc{``0,Microsoft.FSharp.Core.FSharpFunc{``2,``2}},Microsoft.FSharp.Core.FSharpFunc{Microsoft.FSharp.Core.FSharpFunc{``2,Microsoft.FSharp.Core.FSharpFunc{``0,Microsoft.FSharp.Core.FSharpFunc{``1,``2}}},Microsoft.FSharp.Core.FSharpFunc{``2,Microsoft.FSharp.Core.FSharpFunc{``2,``2}}},Microsoft.FSharp.Core.FSharpFunc{``1,Microsoft.FSharp.Core.FSharpFunc{``1,``1}},Microsoft.FSharp.Core.FSharpFunc{``2,Microsoft.FSharp.Core.FSharpFunc{Microsoft.FSharp.Collections.FSharpMap{``0,``1},System.Boolean}})">
<summary>
 Keeps a reference to all persistent collections returned after
 performing an action, and after they are all applied, checks
 that they equal what we would get from FSharp.Core.Map
</summary>
</member>
<member name="M:Prime.Tests.SetTests.eqSetsAfterSteps``2(Microsoft.FSharp.Collections.FSharpSet{``0},``1,Prime.Tests.SetTests.SetAction{``0}[],Microsoft.FSharp.Core.FSharpFunc{``0,Microsoft.FSharp.Core.FSharpFunc{``1,``1}},Microsoft.FSharp.Core.FSharpFunc{``0,Microsoft.FSharp.Core.FSharpFunc{``1,``1}},Microsoft.FSharp.Core.FSharpFunc{Microsoft.FSharp.Core.FSharpFunc{``1,Microsoft.FSharp.Core.FSharpFunc{``0,``1}},Microsoft.FSharp.Core.FSharpFunc{``1,Microsoft.FSharp.Core.FSharpFunc{``1,``1}}},Microsoft.FSharp.Core.FSharpFunc{``0,Microsoft.FSharp.Core.FSharpFunc{``0,``0}},Microsoft.FSharp.Core.FSharpFunc{``1,Microsoft.FSharp.Core.FSharpFunc{Microsoft.FSharp.Collections.FSharpSet{``0},System.Boolean}})">
<summary>
 Keeps a reference to all persistent collections returned after
 performing actions, and after they are all applied, checks
 that they equal what we would get from FSharp.Core.Set
</summary>
</member>
<member name="M:Prime.Program.main(System.String[])">
<summary>
 Run timings.
 NOTE: even if this timing functionality is cleared out, the main entry point must remain in tact due to -
 https://github.com/Microsoft/visualfsharp/issues/1371#issuecomment-235101700
</summary>
</member>
<member name="M:Prime.Program.runMapTimings``1(Microsoft.FSharp.Core.FSharpFunc{System.Tuple{System.String,System.Tuple{System.String,System.String}}[],``0},Microsoft.FSharp.Core.FSharpFunc{System.Tuple{System.String,System.Tuple{System.String,System.String}}[],Microsoft.FSharp.Core.FSharpFunc{``0,Microsoft.FSharp.Core.Unit}},System.String)">
<summary>
 Performs some ad-hoc tests to compare performance of maps.
</summary>
</member>
<member name="M:Prime.Program.runTimings``1(Microsoft.FSharp.Core.FSharpFunc{Microsoft.FSharp.Core.Unit,``0},System.String)">
<summary>
 Performs some ad-hoc tests to compare performance of fns.
</summary>
</member>
<member name="P:Prime.Program.Samples">
<summary>
 The number of samples taken for each timing.
</summary>
</member>
</members>
</doc>
