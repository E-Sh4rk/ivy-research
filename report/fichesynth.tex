
\documentclass{article}

\usepackage[francais]{babel}
\usepackage[T1]{fontenc}
\usepackage[utf8]{inputenc}
\usepackage{a4wide}
\usepackage{palatino}

\let\bfseriesbis=\bfseries \def\bfseries{\sffamily\bfseriesbis}


\newenvironment{point}[1]%
{\subsection*{#1}}%
{}

\setlength{\parskip}{0.3\baselineskip}

\begin{document}
\pagenumbering{gobble}

\title{Generalization of counterexamples for inductive invariant synthesis}

\author{Mickaël Laurent, supervised by Bryan Parno\\Carnegie Mellon University}

\date{March-July 2018}

\maketitle

\pagestyle{empty} %
\thispagestyle{empty}

%% Attention: pas plus d'un recto-verso!


\begin{point}{General context}
  
  As distributed programs become more and more widespread, their verification is a major challenge.
  The general purpose of my internship is to make the certification of those programs easier, by providing new methods and semi-automated tools that will assist the user in this process.
  In this report, we are using IVy, a language combined with a set of tools that can be used to write certified distributed protocols.
  The particularity of IVy is that it restricts the language and the logic used for the specification in order to ensure some decidability properties.
  In particular, checking whether an inductive invariant is correct or not become decidable.

  When writing a protocol using IVy, the two main challenges are
  \begin{itemize}
    \item To implement the protocol and specify it by staying in the decidable fragment imposed by IVy,
    \item Once the previous point is done, to find an inductive invariant.
  \end{itemize}

  During this internship, I have been working on the second point.

\end{point}

\begin{point}{The problem}
  
  The problem we want to solve is the following:
  given an invariant that is not inductive, we want to strenghten it by generating a new (correct) invariant as strong as possible,
  if possible without breaking the decidability of the system.
  This process can be repeated until an inductive invariant is found.

  The current approach to solve this problem is the following:
  \begin{enumerate}
    \item When the invariant is not inductive, a finite counterexample is generated (it can be done in a decidable way).
    \item From this counterexample, a new universal invariant (invariant of the form \(\forall^*\)) is generated. This new invariant aims to `generalize' the counterexample.
  \end{enumerate}
  
  During this internship, I have tried to improve the second point of this process.

\end{point}

\begin{point}{Contributions}

  I have proposed a new way to `generalize' the counterexample. While the current method is based on the
  minimization of a set of constraints using \textit{symbolic bounded verification},
  my approach is based on an analysis of the execution of the counterexample.
  More precisely, I compute a set of constraints that make the current invariant broken at the end of the counterexample,
  and I retropopagate this set of constraints through the execution of the counterexample.
  These constraints are then generalized and the resulting formula is negated.
  This approach also generates universal invariant. It is also quite complementary with the current method
  since both can be combined in order to improve the result.

  Moreover, my approach can be extended with an additional process of `weakening' that
  allows the generation of invariants of the form \(\forall^*\exists^*\) when there is no
  correct universal invariant that can capture the counterexample (in this case, the current method would fail).
  An incorrect universal invariant \(I\) is first generated, and a state `witness' of this incorrectness is searched.
  This state is `generalized' in a similar way as it was done for the counterexample, and then \(I\)
  is weakened in order to allow this kind of state. This process is repeated until \(I\) become correct.
 
\end{point}

\begin{point}{Results and guarantees}

  My approach can sometimes generate universal invariants that are weaker than those generated by the current
  method. However, the two approaches can be combined: a set of constraints can first be generated using my approach,
  and then this set can then be minimized using the current method. The combination of these two methods
  generates better results: invariants generated will be as stronger as using the current method (when it succeed),
  and even when the current method would fail, some invariants can still be generated.

  The new invariants generated with my approach are always correct if the current invariants (those that we want to make inductive)
  are also correct. Symbolic bounded verification or model checking can help us to determine the correctness of these invariants.

\end{point}


\begin{point}{Review and prospects}
  
  Et après? En quoi votre approche est-elle générale? Qu'est-ce que
  votre contribution a apporté au domaine? Que faudrait-il faire
  maintenant? Quelle est la bonne \emph{prochaine} question?

\end{point}


\end{document}







