\documentclass[11pt,a4paper,oldfontcommands]{memoir}
\usepackage[utf8]{inputenc}
\usepackage[T1]{fontenc}
\usepackage{microtype}
\usepackage[dvips]{graphicx}
\usepackage{xcolor}
\usepackage{times}
\usepackage{amsmath}
\usepackage{amsthm}
\usepackage{syntax}
\usepackage{multicol}

\usepackage[
breaklinks=true,colorlinks=true,
%linkcolor=blue,urlcolor=blue,citecolor=blue,% PDF VIEW
linkcolor=black,urlcolor=black,citecolor=black,% PRINT
bookmarks=true,bookmarksopenlevel=2]{hyperref}

\usepackage{geometry}
% PDF VIEW
% \geometry{total={210mm,297mm},
% left=25mm,right=25mm,%
% bindingoffset=0mm, top=25mm,bottom=25mm}
% PRINT
\geometry{total={210mm,297mm},
left=20mm,right=20mm,
bindingoffset=10mm, top=25mm,bottom=25mm}

\OnehalfSpacing
%\linespread{1.3}

%%% CHAPTER'S STYLE
\chapterstyle{bianchi}
%\chapterstyle{ger}
%\chapterstyle{madsen}
%\chapterstyle{ell}
%%% STYLE OF SECTIONS, SUBSECTIONS, AND SUBSUBSECTIONS
\setsecheadstyle{\Large\bfseries\sffamily\raggedright}
\setsubsecheadstyle{\large\bfseries\sffamily\raggedright}
\setsubsubsecheadstyle{\bfseries\sffamily\raggedright}


%%% STYLE OF PAGES NUMBERING
%\pagestyle{companion}\nouppercaseheads 
%\pagestyle{headings}
%\pagestyle{Ruled}
\pagestyle{plain}
\makepagestyle{plain}
\makeevenfoot{plain}{\thepage}{}{}
\makeoddfoot{plain}{}{}{\thepage}
\makeevenhead{plain}{}{}{}
\makeoddhead{plain}{}{}{}


\maxsecnumdepth{subsection} % chapters, sections, and subsections are numbered
\maxtocdepth{subsection} % chapters, sections, and subsections are in the Table of Contents

\newtheorem*{theorem}{Theorem}
\newtheorem*{definition}{Definition}
\newtheorem*{property}{Property}
\newtheorem*{lemma}{Lemma}

%%%---%%%---%%%---%%%---%%%---%%%---%%%---%%%---%%%---%%%---%%%---%%%---%%%

\begin{document}

%%%---%%%---%%%---%%%---%%%---%%%---%%%---%%%---%%%---%%%---%%%---%%%---%%%
%   TITLEPAGE
%
%   due to variety of titlepage schemes it is probably better to make titlepage manually
%
%%%---%%%---%%%---%%%---%%%---%%%---%%%---%%%---%%%---%%%---%%%---%%%---%%%
\thispagestyle{empty}

{%%%
\sffamily
\centering
\Large

~\vspace{\fill}

{\huge 
Invariant Synthesis by Counterexample Generalization
}

\vspace{2.5cm}

{\LARGE
Mickaël LAURENT
}

\vspace{3.5cm}

Carnegie Mellon University\\
Ecole Normale Supérieure Paris-Saclay

\vspace{3.5cm}

Supervisor: Bryan PARNO

\vspace{\fill}

March-July 2018

%%%
}%%%

\clearpage%\cleardoublepage
%%%---%%%---%%%---%%%---%%%---%%%---%%%---%%%---%%%---%%%---%%%---%%%---%%%
%%%---%%%---%%%---%%%---%%%---%%%---%%%---%%%---%%%---%%%---%%%---%%%---%%%

\tableofcontents*

\clearpage

%%%---%%%---%%%---%%%---%%%---%%%---%%%---%%%---%%%---%%%---%%%---%%%---%%%
%%%---%%%---%%%---%%%---%%%---%%%---%%%---%%%---%%%---%%%---%%%---%%%---%%%

\chapter{Presentation of IVy}

    \section{Context}

    As distributed programs become more and more widespread, their verification is a major challenge.

    The general purpose of my internship is to make the certification of those programs easier.
    Certifying a program consists in writing some specifications (in our case, some safety properties), and then proving than the program satisfy them.
    Several languages and tools already exist for that:

    \begin{itemize}
        \item Proof-assistants (Coq, Agda, Why3, etc.):
        The user has to manually write the proof in a interactive way (he can benefit from some help).
        It is a long and complicated process, but once the proof is complete, the proof assistant will always accept it
        if it is correct.
        \item SMT-solver based tools (dafny, F*, Why3, etc.):
        Specifications are automatically checked using a SMT-solver. This process is undecidable in the general case,
        so there are 3 possible outputs:
        \begin{itemize}
            \item Yes, the program matches the specifications
            \item No, the program doesn't match the specifications (sometimes a counterexample can be provided)
            \item I don't know whether the program matches the specifications or not.
        \end{itemize}
        When this last case occurs, the user has to reformulate the specifications differently or to explicitely write some intermediate properties (like inductive invariants)
        in order to help the SMT-solver.
    \end{itemize}

    IVy is a language that allows the user to certify its program using a SMT-solver based approach. [REF]
    However, unlike most of its concurrents, IVy restricts the language and the logic used for specifications
    in order to be able to check the program in a decidable way.

    This approach has many advantages:
    \begin{itemize}
        \item Once the program is written and specified in an accepted logic, it can be checked more easily:
        the checker can always decide whether the program is correct or not, and give a counterexample if it is not.
        \item Our code, specifications and proof indications are not dependent on some heuristics/specificities of the SMT-solver used,
        and so we don't need any specific knowledge.
        \item If a program has been checked using a certain version of IVy, it can also be checked with
        any future version (because it does not depend on any heuristic).
    \end{itemize}
    
    The main disadvantage is that the user is forced to specify its program in a decidable fragment of first order logic:
    it can force him to rethink the architecture of its code, to fragment its code by creating intermediate abstract modules,
    to add some `ghost' variables, etc.

    \section{The RML language}

    IVy is inspired by a modeling language called RML (Relational Modeling Language). It is restricted such that some decidability properties are guaranteed (see section 1.4).
    A RML program is composed of:
    \begin{itemize}
        \item Some uninterpreted types that we call `sorts'. A sort has an unbounded number of elements (`values').
        \item Some variables, relations and functions over these types (a variable can be considered like a function of arity 0, and a relation can be considered as a function
        which returns a boolean). These elements are mutable (their valuation can be modified by the transitions described below).
        \item Some axioms over these variables, functions and relations. Axioms are \(\exists^*\forall^*\) formulas (\( \phi_{EA} \) in the grammar below).
        \item Some transitions that we call `actions'. An action is a \(statement\) (see the grammar below).
        \item A special `init' action that is only executed once at the beginning (before any other action).
    \end{itemize}

    The transitions can be written using the following grammar:
    \begin{multicols}{2}
        \begin{grammar}

            <statement> ::= skip
            \alt abort
            \alt \textbf{r}(\(\bar{x}\)) := \( \phi_{QF}(\bar{x}) \)
            \alt \textbf{f}(\(\bar{x}\)) := \( t(\bar{x}) \)
            \alt \textbf{v} := \( * \)
            \alt assume \( \phi_{EA} \)
            \alt \( statement \) ; \( statement \)
            \alt \( statement \) | \( statement \)
            
        \end{grammar}

        \columnbreak

        \begin{grammar}

            <t> ::= \(x\)
            \alt \textbf{v}
            \alt \textbf{f}(\(t,...t\))
            \alt ite(\( \phi_{QF},t,t\))

            <\( \phi_{QF} \)> ::= \textbf{r}(\(t,\ldots t\))
            \alt \( t = t \)
            \alt \( \phi_{QF} \land \phi_{QF} \) \quad | \quad \( \phi_{QF} \lor \phi_{QF} \) \quad | \quad \( \neg \phi_{QF} \)
            
            <\( \phi_{EA} \)> ::= \( \exists x_1,\ldots,x_n \forall x_{n+1},\ldots,x_{n+m} \phi_{QF} \)

        \end{grammar}
    \end{multicols}

    The semantic of terms and formulas is as usual. The semantic of statements will be described later in the section 1.4.

    One important thing to note is that RML only allows uninterpreted sorts and booleans (and possibly other enumerated types).
    In particular, we can't define arithmetic operations.
    However, we will see later that it is possible to extend it with linear integer arithmetic or some other theories.

    Also, unlike some other languages like F*, IVy does not allow refinement types or dependent types (for decidability reasons).
    As a consequence, we can't encode any property in the types.
    Instead, the specifications of the program will be expressed using assertions and invariants.

    \section{Decidable logics}

    In this section, we will describe the Bernays-Schönfinkel class of formulas. It is a decidable fragment of the first order logic that is used by IVy.
    We will refer to it as EPR (for Effectively Propositional) because this logic can be effectively translated into propositional logic (see the subsection 1.3.2).

        \subsection{The Bernays-Schönfinkel class (EPR)}

        The Bernays-Schönfinkel class is the set of first-order formulas such that:
        \begin{itemize}
            \item Under the prenex normal form, they have an \(\exists^*\forall^*\) quantifier prefix
            (a formula in prenex normal form is composed of a string of quantifiers called the prefix, followed by a quantifier-free part).
            \item They do not use any function symbol (only a finite number of constants and relations).
        \end{itemize}

        For instance, the following formulas define a total relation order and are in the Bernays-Schönfinkel class:
        \begin{align*}
            \forall x. \ R(x,x) &\quad\text{(reflexivity of R)}\\
            \forall x,y,z. \ R(x,y) \land R(y,z) \rightarrow R(x,z) &\quad\text{(transitivity of R)}\\
            \forall x,y. \ R(x,y) \land R(y,x) \rightarrow x=y &\quad\text{(antisymetry of R)}\\
            \forall x,y. \ R(x,y) \lor R(y,x) &\quad\text{(totality of R)}
        \end{align*}

        \subsection{Deciding the satisfiability}

        We want to decide whether an EPR formula is satisfiable or not. Let's consider for instance the following formula:
        \begin{align*}
            F: \exists x. \forall y. \ R(y,y) \land \neg R(x,y)
        \end{align*}

        This formula is not satisfiable, because for any value of \(x\), the formula \(R(y,y) \land \neg R(x,y)\) is false when we take \(y=x\).
        However, there is infinitely many possible interpretations for the relation \(R\) (because the set of possible values for \(x\) and \(y\) is not bounded).
        So how to decide the satisfiabilty of such formulas?

        First, we can get rid of the existential quantifier by introducing a new constant \(A\):
        \begin{align*}
            \forall y. \ R(y,y) \land \neg R(A,y)
        \end{align*}

        This is called the skolem normal form of \(F\).
        Note that in the general case, we can eliminate any existential quantifier in a formula in prenex normal form by introducing a new function
        that depends on all universally quantified variables in its scope. This process is called `skolemization' and preserve the satisfiability of the formula.

        \begin{property}[Skolemization]
            Let \(F\) be a formula and \(F'\) be the formula obtained after solemization if \(F\). Then \(F\) is satisfiable iff \(F'\) is satisfiable.
        \end{property}

        Now, we want to restrict the domain of the possible interpretations in order to be able to decide the satisfiability of our formula.

        \begin{definition}[Herbrand domain]
            The Herbrand domain of a formula is the set of every term that can be written with the constants and functions symbols present in the formula
            (if there is no constant symbol in the formula, we introduce a new one).
        \end{definition}

        Our formula has a unique constant \(A\) and no function symbol (only a relation symbol), so its Herbrand domain is the following:
        \( \{A\} \). More generally, we have the following property:
        
        \begin{property}
        The Herbrand domain of an EPR formula is finite.
        \end{property}

        Thus, we can decide whether or not our formula is satisfiable by an interpretation over it's Herbrand domain.
        For that, we just have to test every interpretation of \(R\) over the domain \( \{A\} \):

        \begin{itemize}
            \item With \(R(A,A)=\text{false}\): \(\forall y. \ R(y,y) \land \neg R(A,y)\) is false (with \( y \in \{A\} \))
            \item With \(R(A,A)=\text{true}\): \(\forall y. \ R(y,y) \land \neg R(A,y)\) is false (with \( y \in \{A\} \))
        \end{itemize}

        So our formula is not satisfiable by any interpretation over it's Herbrand domain.

        Finally, by applying the following theorem, we can conclude that our formula is not satisfiable by any interpretation (over any domain):
        \begin{theorem}[Herbrand]
            An universally quantified first-order formula \(F\) is satisfiable iff it is satisfied by an interpretation over it's Herbrand domain.
        \end{theorem}

        This process can be used to decide the satisfiability of any EPR formula. Moreover, when a formula is satisfiable,
        it gives us an interpretation over the Herbrand domain that satisfy the formula (= a model).
        The Herbrand domain being finite, we have the following property:

        \begin{property}[Finite model property]
            Every satisfiable EPR formula has a finite model.
        \end{property}

        \subsection{EPR with types}

        In RML, relations, functions and constants (that are preferably called `variables' since they are mutable) have types.
        For instance, a function takes arguments of some specific sorts and also return a value in a specific sort (sorts are unbounded set of values).

        We can easily add these typing constraints to the logical symbols we used in the previous subsection.
        Moreover, it allows us to extend the domain of EPR formulas by keeping a finite Herbrand domain.

        Indeed, we can allow function symbols and \(\forall^*\exists^*\) quantifier alternation as long as,
        when skolemized, the formula still has a finite Herbrand domain.
        In particular, function symbols are allowed as long as they are stratified (that is, as long as there exists
        an order over the sorts such that, for every function \( f: t_1 \to t_2 \), we have \( t_1 < t_2 \)).

        However, the EPR fragment can still be too restrictive: for instance, we can't introduce linear arithmetic using only EPR axioms.
        Indeed, the standard way to define integers is to introduce a successor function symbol, which is not allowed because it is not stratified.
        More generally, we can't characterize any infinite set with only EPR axioms: it would contradict the finite model property.

        \subsection{Extensions of EPR}

        Some strict extensions of EPR are still decidable.
        In particular, SMT-solvers like Z3 [ref] are able to decide the Finite Almost Uninterpreted (FAU) fragment of first order logic,
        which add to EPR some usual interpreted symbols of Linear Arithmetic (integer constants, `+', `\( \leq \)') under some additional constraints.
        You can refer to [REF] for more details about it. 
        
        In this report, we will not use such extension of EPR, because it breaks the finite model property.
    
    \section{Checking a RML program}

    \begin{definition}[State]
        A state of a RML program is a pair \(((D_s)_{s\in \text{sorts}}, (I_s)_{s\in \text{symbols}})\) where:
        \begin{itemize}
            \item For all \(s \in \text{sorts}\), \(D_s\) is a finite domain associated to the sort \(s\).
            \item For all \(s \in \text{symbols}\) (variable, function or relation), \(I_s\) is an interpretation (=valuation) for the symbol \(s\) over the corresponding domains of \((D_s)\).
        \end{itemize}
        A state must satisfy every axiom defined in the RML program.
    \end{definition}

    In order to certify that a RML program never abort abnormally, we must provide IVy with an invariant \(I\) such that:
    \begin{enumerate}
        \item \(I\) is initially satisfied (after any execution of the `init' action from any state).
        \item \(I\) is inductive, that is: for any state satisfying \(I\), the new state of the program after executing any action of the RML program must also satisfy \(I\).
        This also implies that actions never abort abnormally from a state satisfying \(I\).
    \end{enumerate}

    In order to check whether a formula satisfies all these properties, we introduce the notion of weakest precondition \(wp\):
    \begin{definition}[Weakest precondition]
        For any statement \(S\) and formula \(Q\), the weakest precondition of \(Q\) by \(S\) (noted \(wp(S,Q)\)) is the weakest formula \(P\) such that
        every execution of \(S\) starting from a state satisfying \(P\) will lead to a state that satisfies \(Q\).
    \end{definition}

    Weakest preconditions can be computed as below:\\

    \begin{tabular}{|l|l|l|}
        \hline
        Statement & Semantic & \( wp(\text{statement},Q) \) \\
        \hline
        skip & Do nothing & \(Q\) \\
        abort & Terminate abnormally (fail) & false \\
        \textbf{r}(\(\bar{x}\)) := \( \phi_{QF}(\bar{x}) \) & Quantifier-free update of relation \textbf{r} & \((A \rightarrow Q) [\phi_{QF}(\bar{s})\ /\ \text{\textbf{r}}(\bar{s})]\) \\
        \textbf{f}(\(\bar{x}\)) := \( t(\bar{x}) \) & Update of function \textbf{f} to term \( t(\bar{x}) \) & \((A \rightarrow Q) [t(\bar{s})\ /\ \text{\textbf{f}}(\bar{s})]\) \\
        \textbf{v} := \( * \) & Non-deterministic assignment of variable \textbf{v} & \(\forall x. (A \rightarrow Q) [x\ /\ \text{\textbf{v}}]\)\\
        assume \( \phi_{EA} \) & Assume a \( \exists^*\forall^* \) formula holds & \( \phi_{EA} \rightarrow Q \) \\
        \( S_1 \) ; \( S_2 \) & Sequential composition & \( wp(S_1, wp(S_2, Q)) \) \\
        \( S_1 \) | \( S_2 \) & Non-deterministic choice & \( wp(S_1, Q) \land wp(S_2, Q) \) \\
        \hline
    \end{tabular}\\ \\
    \( \phi(\beta,\alpha) \) denotes \(\phi\) with occurences of \(\alpha\) substituted by \(\beta\), and \(A\) denotes the axioms of the RML program.
    \\
    \\
    We can now rewrite the properties above using weakest preconditions:
    \begin{enumerate}
        \item \(A \rightarrow wpr(\text{init},I)\)
        \item For every action \(S\), \(A \land I \rightarrow wpr(\text{S},I)\)
    \end{enumerate}

    \begin{lemma}
        Let \(S\) be a RML statement and \(Q\) a \(\forall^*\exists^*\) formula (that is a formula whose normal prenex form has a \(\forall^*\exists^*\) prefix followed by a quantifier-free part), then \(wp(S,Q)\) is also a \(\forall^*\exists^*\) formula.
    \end{lemma}

    This lemma can easily be proved by induction on \(S\).
    
    Moreover, according to the section 1.3, \(\exists^*\forall^*\) formulas can be checked if function symbols are stratified.
    We can deduce the following theorem:

    \begin{theorem}[]
        % TODO
    \end{theorem}

    % TODO

    \section{Interactive tools to find an inductive invariant}

    \section{Challenges}

%\chapter{Research directions}
%    \section{Make code EPR}
%        \subsection{Fragmentation}
%        \subsection{Adding relations}
%    \section{Adding typing}
%    \section{Invariant Synthesis}

\chapter{Invariant Synthesis}

    \section{Using weakest precondition}

    \section{Counterexample generalization}

    \section{Limits}

\chapter{My contributions}

    \section{Filtering constraints using code analysis}

    \section{Model-dependent constraints}

    \section{Weakening the conjecture}

    \section{Guarantees}

    \section{Comparison to other methods}

\chapter{Conclusion}

    \section{What remains to be done}

    \section{Lessons from this internship}

\bibliographystyle{unsrt}
\bibliography{sample}

\end{document}

